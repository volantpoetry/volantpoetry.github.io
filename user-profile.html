<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Profile | Volant Poetry</title>

<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@500;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@700&display=swap" rel="stylesheet">
  
<link rel="stylesheet" href="style.css" />
<link rel="icon" type="image/png" href="images/logo.png" />
<link rel="apple-touch-icon" href="images/logo.png" />

<style>
:root {
  --primary: #4b2aad;
  --bg: #f7f5ff;
  --text: #1a1a1a;
  --muted: #666;
  --radius: 14px;
}

body {
  font-family: 'Inter', sans-serif;
  background: var(--bg);
  color: var(--text);
  margin: 0;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
}

header {
  width: 100%;
}

/* Profile Section */
.profile-container {
  background: #fff;
  padding: 2rem;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  width: 90%;
  max-width: 500px;
  text-align: center;
  margin-top: 40px;
}

.profile-container h2 { color: var(--primary); margin-bottom: 1rem; }

.profile-picture img {
  width: 100px;
  height: 100px;
  border-radius: 50%;
  object-fit: cover;
  margin-bottom: 0.8rem;
  border: 3px solid var(--primary);
}

.profile-info { margin: 1rem 0; font-size: 1rem; color: #333; }
.profile-info p { margin: 0.5rem 0; }

.btn {
  padding: 0.5rem 1rem;
  background: var(--primary);
  color: #fff;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: 0.2s;
  margin-top: 0.5rem;
}

.btn:hover { background: #6c3ddd; }

#editProfileBtn { background: #fff; color: var(--primary); border: 1px solid var(--primary); }
#editProfileBtn:hover { background: var(--primary); color: #fff; }

/* Poems Section */
.profile-poems {
  width: 100%;
  max-width: 900px;
  margin: 40px auto;
  transform: translateX(40px);
}

h2 {
  text-align: center;
  font-family: 'Playfair Display', serif;
  font-weight: 600;
  margin: 20px auto 30px auto;
  color: #4b2aad;
}

.profile-poems h3 {
  color: var(--primary);
  text-align: left;
  font-family: 'Playfair Display', serif;
  margin-bottom: 1.5rem;
}

.recent-poem-card {
  background: linear-gradient(160deg, #fdf6f0, #e2e9f0);
  color: #4b3f2f;
  border-radius: 12px;
  padding: 1.2rem;
  margin-bottom: 2rem;
}
/* Center on small screens */
@media (max-width: 768px) {
  .recent-poem-card {
    margin-left: -5;
    margin-right: auto;
    width: 100%; /* optional: make it responsive */
  }
}
.poem-content {
  white-space: pre-wrap;
  line-height: 1.7;
  overflow: hidden;
    padding-left: 12px; /* moves text slightly to the right */
}

/* --- Force smaller comment box --- */
.recent-poem-card .comment-section {
  display: flex;
  align-items: center;
  justify-content: flex-start;
  gap: 8px;
}

.recent-poem-card .comment-input {
  flex: none !important;        /* stop auto-stretching */
  width: 220px !important;      /* fixed smaller width */
  max-width: 65% !important;    /* optional safety */

}
/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Desktop Layout (Two-Column) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
@media (min-width: 900px) {
  .profile-layout {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 40px;
    width: 90%;
    max-width: 1100px;
    margin-top: 50px;
  }

  .profile-container {
    max-width: 100%;
    margin: 0;
    text-align: left;
  }

  .profile-container h2 {
    text-align: left;
  }

  .interaction-panel {
    background: #fff;
    border-radius: 12px;
    box-shadow: 0 3px 10px rgba(0,0,0,0.08);
    padding: 1.5rem;
    height: fit-content;
  }

  .interaction-panel h3 {
    font-family: 'Playfair Display', serif;
    color: var(--primary);
    font-weight: 600;
    margin-bottom: 1rem;
  }

  .interaction-panel ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .interaction-panel li {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 0;
    border-bottom: 1px solid #eee;
    cursor: pointer;
    transition: 0.2s;
  }

  .interaction-panel li:hover {
    color: var(--primary);
    background: #f7f5ff;
    border-radius: 8px;
    padding-left: 10px;
  }
}

/* Poem section stays full width below both columns */
.profile-poems {
  grid-column: 1 / span 2;
  width: 90%;
  max-width: 1100px;
  margin-top: 50px;
  transform: none;
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Search Bar Styling ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Search Bar Styling ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.search-bar {
  display: flex;
  align-items: center;
  justify-content: flex-end; /* Move to right */
  gap: 10px;
  margin: 20px auto 30px;
  width: 100%;              /* Full width container */
  max-width: 900px;         /* Keeps it aligned with your cards */
  padding-right: 50px;      /* Push in from right edge */
}

.search-bar input {
  flex: 0 1 250px;          /* Fixed input width but still responsive */
  padding: 10px 14px;
  font-size: 15px;
  border: 1px solid #ddd;
  border-radius: var(--radius);
  outline: none;
  transition: 0.2s;
  background: #fff;
}

.search-bar input:focus {
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(75, 42, 173, 0.1);
}
.search-bar {
  display: flex;
  justify-content: flex-end;
  align-items: center;
  margin: 10px 0 20px;
  width: 100%;
  padding-right: 15px; /* tighter spacing */
}

.search-bar input {
  width: 150px;               /* smaller width */
  padding: 6px 10px;          /* reduced height */
  font-size: 14px;            /* slightly smaller text */
  border: 1px solid #ccc;
  border-radius: 10px;        /* cute rounded shape */
  outline: none;
  transition: 0.2s;
  background: #fafafa;        /* soft cute look */
}

/* Cute hover & focus effect */
.search-bar input:focus {
  border-color: #999;
  background: #fff;
  box-shadow: 0 0 4px rgba(0,0,0,0.1);
}


.search-bar input:focus {
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(75, 42, 173, 0.1);
}
@media (max-width: 600px) {
  .search-bar {
    width: 50%;             /* narrower on small screens */
    margin-left: auto;      /* push container to the right */
    justify-content: flex-end;
    padding-right: 10px;
  }

  .search-bar input {
    width: 50px !important; /* force small width */
    padding: 5px 8px;
    font-size: 12px;
  }
}

/* Flex container for profile picture + info */
.profile-header-flex {
  display: flex;
  flex-direction: column; /* stack on mobile */
  align-items: center;
  gap: 20px;
}

/* Profile picture section with followers below */
.profile-picture-section {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.follow-info-horizontal {
  display: flex;
  justify-content: center;
  gap: 20px;
  margin-top: 10px;
}

.follow-item {
  text-align: center;
}

/* Profile info on the right */
.profile-info-right {
  display: flex;
  flex-direction: column;
  gap: 10px;
  text-align: left;
    line-height: 0.95; /* tighten lines */
      margin-left: 10px; /* move closer to the profile picture */
}
.profile-info-right p {
  margin: 4px 0; /* small vertical spacing between lines */
}

/* Desktop layout */
@media (min-width: 900px) {
  .profile-header-flex {
    flex-direction: row; /* picture on left, info on right */
    align-items: flex-start;
  }

  .profile-picture-section {
    align-items: center;
  }

  .profile-info-right {
    margin-left: 40px; /* space between picture and info */
  }
}
@media (min-width: 900px) {
  .profile-info-right {
    margin-left: 20px; /* tighter spacing on desktop */
  }
}
/* Move followers/following to the left on desktop */
@media (min-width: 900px) {
  .follow-info-horizontal {
    justify-content: flex-start; /* align to the left instead of center */
    margin-left: 0;              /* remove extra margin if any */
  }
}
.interaction-panel ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.interaction-panel li {
  padding: 10px 0;
  border-bottom: 1px solid #eee;
}

.interaction-panel li a {
  display: flex;
  align-items: center;
  gap: 10px;
  text-decoration: none;  /* remove underline */
  color: var(--text);
  width: 100%;
  transition: 0.2s;
}

.interaction-panel li a:hover {
  color: var(--primary);
  background: #f7f5ff;
  border-radius: 8px;
  padding-left: 10px;
}
/* Full-width horizontal profile stats */
.profile-stats-section {
  width: 100%;               /* Take full page width */
  background: #fff;          /* Optional background */
  padding: 20px 40px;        /* Some spacing */
  margin: 40px 0;            /* Top & bottom spacing */
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  display: flex;
  gap: 30px;                 /* Space between panels */
  overflow-x: auto;          /* Allow horizontal scrolling if screen is small */
  box-sizing: border-box;    /* Include padding in width */
}

/* Each panel item inside stats */
.interaction-panel-horizontal {
  display: flex;
  gap: 40px;
}

.panel-item {
  min-width: 200px;          /* Ensure panels don‚Äôt collapse */
  flex: 1;                   /* Equal width stretch */
  background: #f7f5ff;       /* Optional distinct background */
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.05);
}

/* Level bar */
.level-bar {
  width: 100%;
  height: 12px;
  background: #ddd;
  border-radius: 6px;
  margin-top: 8px;
}
#levelProgress {
  height: 100%;
  background: var(--primary);
  border-radius: 6px;
}


/* Make sure the horizontal profile stats are responsive */
.profile-stats-section {
  width: 100%;
  background:  #f7f5ff;
  padding: 20px 40px;
  margin: 40px 0;
  box-shadow: 0 4px 12px  #f7f5ff;
  display: flex;
  overflow-x: auto;
  gap: 30px;
  box-sizing: border-box;
}

.interaction-panel-horizontal {
  display: flex;
  gap: 30px;
}

.panel-item {
  min-width: 220px;
  flex: 1;
  background: #f7f5ff;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 2px 8px  #B8860B;
}

.badges-container img {
  width: 40px;
  height: 40px;
}

/* Shift the profile layout slightly to the right */
.profile-layout {
  margin-left: 40px; /* adjust px as needed */
}

/* Shift the horizontal stats section to the right as well */
.profile-stats-section {
  margin-left: 70px; /* match the layout shift */
  margin-right: 40px; /* optional: keeps spacing consistent on the right */
}

/* Optional: shift poems section as well */
.profile-poems {
  margin-left: 40px; /* aligns poems with profile layout */
  margin-right: 40px; 
}

.top-poem-link {
  display: block;
  color:  #B8860B;
  text-decoration: none;
  margin: 6px 0;
  font-weight: 600;
  transition: color 0.2s ease;
}

.top-poem-link:hover {
  color: #1a73e8;
}
.profile-picture img {
  width: 180px;           /* üî• bigger circle size */
  height: 180px;
  border-radius: 50%;
  object-fit: cover;
  object-position: center;
  border: 4px solid #ccc;
  box-shadow: 0 0 15px rgba(0,0,0,0.15);
  image-rendering: high-quality;
  transition: transform 0.3s ease;
}

.profile-picture img:hover {
  transform: scale(1.05); /* subtle hover zoom for polish */
}


/* --- Image Modal --- */
.image-modal {
  display: none; /* Hidden by default */
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0,0,0,0.85);
  backdrop-filter: blur(3px);
  align-items: center;
  justify-content: center;
}

.image-modal img {
  max-width: 90%;
  max-height: 90%;
  border-radius: 12px;
  box-shadow: 0 0 30px rgba(255,255,255,0.2);
  animation: zoomIn 0.3s ease;
}

.close-modal {
  position: absolute;
  top: 20px;
  right: 40px;
  color: white;
  font-size: 40px;
  font-weight: bold;
  cursor: pointer;
  transition: 0.2s;
}

.close-modal:hover {
  color: #ff6666;
}

@keyframes zoomIn {
  from { transform: scale(0.9); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}
#topPoemContent span {
  display: block;
  margin-bottom: 4px;
}

.logout-nav-btn {
  display: inline-block;
  margin-left: 20px;
  padding: 6px 12px;
  font-size: 14px;
  background: var(--primary);
  color: #fff;
  border-radius: 8px;
  border: none;
  cursor: pointer;
  z-index: 50; /* ensure it‚Äôs above other elements */
}

.logout-nav-btn:hover {
  background: #6c3ddd;
}

.nav-right {
  display: flex;
  align-items: center;
  gap: 10px;
}
/* Move "My Profile" to left edge on small screens */
@media (max-width: 899px) {
  .profile-container {

 
    text-align: left;   /* align text left */
        width: 80%;         /* full width */
           font-size: 0.9rem; /* smaller text */
             background-color: #4b2aad; /* new background color */
  }

  .profile-header-flex {
    align-items: flex-start; /* align picture + info to left */
  }

  .profile-info-right {
    margin-left: 15px; /* small spacing from profile picture */
    text-align: left;
  }

  .profile-picture-section {
    align-items: flex-start; /* move picture to left */
  }

  .follow-info-horizontal {
    justify-content: flex-start; /* followers left-aligned */
  }
  
}

/* Small screens (keep info to the right of image) */
@media (max-width: 899px) {
  .profile-header-flex {
    flex-direction: row; /* side by side */
    align-items: flex-start; /* top-aligned */
    justify-content: flex-start; /* optional */
    gap: 15px; /* space between image and info */
  }

  .profile-picture-section {
    flex-shrink: 0; /* prevent shrinking */
  }

  .profile-info-right {
    margin-left: 0; /* spacing handled by gap */
    text-align: left;
  }
  
}
@media (max-width: 899px) {
  .profile-picture {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: flex-start; /* force left alignment */
    padding-bottom: 0; /* optional, remove extra space */
  }

  #changePicBtn {
    position: absolute;
    bottom: -10px;  /* adjust vertical position */
    left: 0 !important; /* force left alignment */
    width: 110px; /* reduce width */
    font-size: 0.7rem; /* smaller text */
    padding: 5px 10px; /* adjust padding */
  }
}

@media (max-width: 899px) {
  #editProfileBtn {
    font-size: 0.8rem;      /* smaller text */
    padding: 5px 10px;      /* smaller button */
    width: auto;            /* optional: shrink to content */
  
}
}

@media (max-width: 600px) {
  h2 {
    font-size: 1.2rem;
    text-align: center;
  }
}

@media (max-width: 600px) {
  .nav-logo-img {
    width: 40px;  /* smaller logo image */
  }

  .logo-text {
    font-size: 1rem; /* smaller text */
  }

  .logo {
    margin-left: 10px; /* optional, keep it from touching the edge */
  }
}
/* Shift title and author slightly to the right */
.poem-title,
.poem-author {
  margin-left: 15px; /* adjust as needed */
}

/* Reduce width of comment input and align with card */
.comment-aligned {
  display: flex;
  align-items: center;
  gap: 8px; /* space between inputs and buttons */
  margin-left: 15px; /* same offset as title/author */
}

.comment-aligned .comment-input {
  flex: 1;       /* input takes remaining space */
  max-width: 200px; /* reduced width */
  padding: 6px 10px;
  border-radius: 6px;
  border: 1px solid #ccc;
  font-size: 0.9rem;
}
@media (max-width: 600px) {
  .profile-info-right,
  .profile-info-right p,
  .profile-info-right span,
  .profile-info-right strong {
    color: white !important;
  }

  .profile-buttons .btn {
    color: white !important;
    border-color: white !important;
      background: transparent !important;
  }
}
@media (max-width: 480px) {
  .recent-poem-card {
    margin-bottom: 18px !important;  /* gap between cards */
  }
    }

    /* Container for all badges */
  #badgesContainer {
    display: flex;          /* Horizontal layout */
    flex-wrap: wrap;        /* Wrap to next line if too many */
    justify-content: flex-start; /* Align items to the left */
    gap: 10px;              /* Space between badges */
    margin-top: 10px;
  }

  /* Individual badges */
  #badgesContainer img {
    width: 50px;
    height: 50px;
    border-radius: 50%;     /* Circular badges */
    object-fit: cover;
    border: 2px solid #5a3cb3;  /* Optional border for style */
    box-shadow: 0 2px 4px rgba(0,0,0,0.2); /* Subtle shadow */
    transition: transform 0.2s;    /* Hover effect */
    cursor: default;
  }

  #badgesContainer img:hover {
    transform: scale(1.1); /* Slight zoom on hover */
  }
/* ‚îÄ‚îÄ‚îÄ Volant Classic Initial Avatar ‚îÄ‚îÄ‚îÄ */
.volant-avatar {
  width: 180px;
  height: 180px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;

  font-family: 'Playfair Display', serif;
  font-weight: 700;
  font-size: 3rem;
  letter-spacing: 2px;

  /* Classic ink tone */
  color: #2b1f14;

  /* Paper-like background */
  background:
    radial-gradient(circle at top left, rgba(255,255,255,0.6), rgba(0,0,0,0.03)),
    linear-gradient(135deg, #f6efe7, #e9dfd2);

  /* Elegant frame */
  border: 4px solid #b89b5e; /* antique gold */
  box-shadow:
    inset 0 0 0 6px #fdfaf5,
    0 6px 18px rgba(0,0,0,0.18);

  user-select: none;
  position: relative;
}

/* Inner soft ring */
.volant-avatar::before {
  content: "";
  position: absolute;
  inset: 10px;
  border-radius: 50%;
  border: 1px solid rgba(0,0,0,0.12);
}

/* Initials styling */
/* ‚îÄ‚îÄ‚îÄ Default Generated User Name (Initials Avatar Only) ‚îÄ‚îÄ‚îÄ */
#avatarInitials {
  font-family: 'Libre Baskerville', Georgia, serif;
  font-weight: 700;
  font-size: 3.2rem;     /* controls ONLY the initials size */
  letter-spacing: 3px;
  text-transform: uppercase;
  line-height: 1;
}

.volant-avatar.stamp {
  background: #2f1b12;
  color: #f5e6c8;
  border-color: #7a4b2e;
  box-shadow:
    inset 0 0 20px rgba(0,0,0,0.5),
    0 8px 20px rgba(0,0,0,0.3);
}
/* Regenerate Avatar button styling */
#regenerateAvatarBtn {
  margin-left: 10px;        /* spacing from the previous button */
  padding: 8px 16px;        /* button padding */
  background-color: #4CAF50; /* green background */
  color: #fff;              /* white text */
  border: none;             /* remove default border */
  border-radius: 6px;       /* rounded corners */
  cursor: pointer;          /* pointer on hover */
  font-size: 0.9rem;        /* slightly smaller font */
  transition: background-color 0.3s, transform 0.2s; /* smooth hover effect */
}

/* Hover effect */
#regenerateAvatarBtn:hover {
  background-color: #45a049; /* slightly darker green */
  transform: scale(1.05);    /* slight zoom effect */
}

/* Optional: active/pressed state */
#regenerateAvatarBtn:active {
  transform: scale(0.98);    /* press effect */
}


/* Delete button inside poem card */
.recent-poem-card .delete-btn {
  background-color: #ff4d4d;       /* bright red for delete */
  color: white;
  border: none;
  border-radius: 6px;
  padding: 4px 10px;
  cursor: pointer;
  font-size: 14px;
  margin-left: 8px;
  transition: background-color 0.2s;
}

.recent-poem-card .delete-btn:hover {
  background-color: #e60000;       /* darker red on hover */
}

.recent-poem-card .delete-btn:active {
  transform: scale(0.95);          /* slight click animation */
}


@media screen and (max-width: 600px) {
  .recent-poem-card .delete-btn {
    font-size: 12px;
    padding: 2px 6px;
    margin-left: auto;
  }
}

/* Default: show delete button on all screens at top-right of the card */
.recent-poem-card {
  position: relative; /* make sure absolute positioning works */
}

.recent-poem-card .delete-btn {
  position: absolute;
  top: 8px;
  right: 8px;
  font-size: 14px;
  padding: 4px 8px;
  background: #ff4d4d;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
}

/* Small screens: make it smaller and compact */
@media screen and (max-width: 600px) {
  .recent-poem-card .delete-btn {
    font-size: 12px;
    padding: 2px 6px;
  }

  /* Optional: reduce size of other poem action buttons on small screens */
  .recent-poem-card .poem-actions button,
  .recent-poem-card .poem-actions textarea {
    font-size: 12px;
    padding: 4px 6px;
  }
}

/* Shift date, categories, and read more button to the right */
.poem-date {
  margin-left: 15px !important;
  display: block;
  color: #008080; /* Teal */

}

.poem-category-line {
  margin-left: 15px !important;
}

.read-more-btn {
  margin-left: 15px !important;
}
/* Small screens - reduce font size, move left */
@media (max-width: 768px) {
  .poem-date,
  p.poem-category-line,
  .read-more-btn {
    margin-left: -5px !important;
    font-size: 0.7rem !important;
  }
  
  /* Move categories SLIGHTLY UP */
  p.poem-category-line {
    margin-top: -2px !important;  /* Slightly up, not too much */
    margin-bottom: 6px !important;
  }
  
  .poem-category-line em {
    font-size: 0.7rem !important;
  }
}

/* Even smaller screens */
@media (max-width: 600px) {
  .poem-date,
  p.poem-category-line,
  .read-more-btn {
    margin-left: -8px !important;
    font-size: 0.65rem !important;
  }
  
  /* Move categories SLIGHTLY UP */
  p.poem-category-line {
    margin-top: -3px !important;  /* Slightly more up */
    margin-bottom: 5px !important;
  }
  
  .poem-category-line em {
    font-size: 0.65rem !important;
  }
}

/* Very small screens */
@media (max-width: 480px) {
  .poem-date,
  p.poem-category-line,
  .read-more-btn {
    margin-left: -10px !important;
    font-size: 0.6rem !important;
  }
  
  /* Move categories SLIGHTLY UP */
  p.poem-category-line {
    margin-top: -4px !important;  /* Slightly more up */
    margin-bottom: 4px !important;
  }
  
  .poem-category-line em {
    font-size: 0.6rem !important;
  }
}


/* Fix for small screens - remove left margin from profile layout */
@media (max-width: 899px) {
  .profile-layout {
    margin-left: 0 !important; /* Remove the 40px left margin on mobile */
    width: 100%;
    padding: 0 15px; /* Add small padding instead */
    box-sizing: border-box;
  }
  
  /* Also adjust the stats section */
  .profile-stats-section {
    margin-left: 0 !important;
    margin-right: 0 !important;
    padding: 20px 15px;
    width: 100%;
    box-sizing: border-box;
  }
  
  /* Adjust poems section */
  .profile-poems {
    margin-left: 0 !important;
    margin-right: 0 !important;
    padding: 0 15px;
    width: 100%;
    box-sizing: border-box;
  }
  
  /* Make the Volant Quick panel full width on mobile */
  .interaction-panel {
    width: 100%;
    margin-top: 20px;
  }
}

/* Even smaller screens */
@media (max-width: 600px) {
  .profile-layout {
    padding: 0 10px;
  }
  
  .profile-stats-section {
    padding: 15px 10px;
  }
  
  .profile-poems {
    padding: 0 10px;
  }
}

/* SMALL SCREENS ONLY - Stack everything under profile image */
@media (max-width: 899px) {
  .profile-header-flex {
    flex-direction: column !important;
    align-items: flex-start !important; /* Changed from center to flex-start */
    display: flex !important;
  }
  
  .profile-picture-section {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center; /* Keep picture centered */
    order: 1;
  }
  
  .profile-info-right {
    width: 100%;
    text-align: left !important; /* Changed from center to left */
    margin-left: 0 !important;
    order: 2;
    display: block !important;
    padding-left: 10px; /* Add slight padding from left edge */
  }
  
  .follow-info-horizontal {
    justify-content: center !important;
    margin-top: 20px;
    width: 100%;
    order: 3;
    display: flex !important;
  }
  
  .profile-picture {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
  }
  
  .profile-info-right p {
    text-align: left !important; /* Left align all paragraphs */
    margin: 8px 0;
    color: white !important;
  }
  
  .profile-info-right p strong {
    display: inline-block;
    min-width: 80px;
    color: rgba(255, 255, 255, 0.8);
  }
  
  .profile-info-right p span {
    color: white;
  }
  
  .profile-buttons {
    display: flex;
    justify-content: flex-start !important; /* Changed from center to flex-start */
    margin-top: 15px;
    padding-left: 10px; /* Match the padding of profile-info-right */
  }
  
  #editProfileBtn {
    color: white !important;
    border-color: white !important;
    background: transparent !important;
    margin: 0; /* Remove auto margin */
  }
  
  .follow-item {
    color: white;
  }
  
  .follow-item strong {
    color: white;
    display: block;
    font-size: 1.2rem;
  }
  
  .follow-item span {
    color: rgba(255, 255, 255, 0.8);
    font-size: 0.9rem;
  }
  
  /* Hide the profile container title on small screens */
  .profile-container h2 {
    display: none;
  }
  
  /* Adjust container background */
  .profile-container {
    background-color: #4b2aad !important;
    padding: 20px !important;
  }
}
</style>
</head>

<body>
<header>
  <nav>
    <div class="logo">
      <img src="images/logokk.png" alt="Volant Poetry Logo" class="nav-logo-img">
      <span class="logo-text">
        <span class="logo-highlight">Volant</span> Poetry
      </span>
    </div>

    <div class="nav-links" id="nav-links">
      <span class="close-btn" id="close-btn">‚úï</span>
      <a href="index.html">Home</a>
      <a href="about.html">About</a>
       <a href="contact.html">Contact Us</a> <!-- ‚úÖ New link -->
    </div>
<div class="nav-right">

<!-- Mobile Icons -->
    <div class="mobile-icons">
  <!-- Logout Button -->
  <button id="logoutBtnNav" class="btn logout-nav-btn">Logout</button>
  </div>

      <div class="menu-toggle" id="menu-toggle">‚ò∞</div>
    </div>
</nav>
</header>

<!-- PROFILE + QUICK ACCESS WRAPPER -->
<div class="profile-layout">

  <!-- Profile Container (Left Column) -->
  <div class="profile-container">
    <h2>Profile</h2>

    <div class="profile-header-flex">
      <div class="profile-picture-section">
        <div class="profile-picture">
<div id="profileAvatar" class="volant-avatar">
  <span id="avatarInitials"></span>
</div>

<img id="profilePic" style="display:none;" alt="Profile Picture">

          <input type="file" id="uploadPic" style="display:none;">
          <button class="btn" id="changePicBtn">Change Picture</button>
   <button id="regenerateAvatarBtn" style="display:none; margin-left: 10px;">Regenerate Avatar</button> </div>

        <div class="follow-info-horizontal">
          <div class="follow-item">
            <strong id="followersCount">0</strong>
            <span>Followers</span>
          </div>
          <div class="follow-item">
            <strong id="followingCount">0</strong>
            <span>Following</span>
          </div>
        </div>
      </div>

      <div class="profile-info-right">
        <p><strong>Real Name:</strong> <span id="realName"></span></p>
        <p><strong>Username:</strong> <span id="username"></span></p>
        <p><strong>Email:</strong> <span id="email"></span></p>
        <p><strong>Bio:</strong> <span id="bio"></span></p>
        <p><strong>Joined:</strong> <span id="joined"></span></p>
        <div class="profile-buttons">
          <button class="btn" id="editProfileBtn">Edit Profile</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Quick Access (Right Column) -->
  <div class="interaction-panel">
    <h3>Volant Quick</h3>
    <ul>
      
      <li><a href="notifications.html">üîî Notifications</a></li>
      <li><a href="messages.html">‚úâ Messages</a></li>
        <li><a href="submitpoems.html">üìù Submit Poems</a></li>
         <li><a href="user-edit-poems.html">Edit Your Poems</a></li>
             <li><a href="submit-draft.html">Save as Draft</a></li>
                  <li><a href="drafts-manager.html">Manage Draft Poems</a></li>
                   <li><a href="gallery-achievements.html">üèÜ Achievement Gallery üèÜ</a></li>

    </ul>
  </div>

</div>

<!-- HORIZONTAL PROFILE STATS (Full Width Section) -->
<section class="profile-stats-section">
  <div class="interaction-panel-horizontal">

<div class="panel-item">
  <h3>Flight Stage</h3>
  <strong>Flight</strong> <span id="userLevel"></span> <!-- Using your existing ID -->
  <div class="level-bar">
    <div id="levelProgress" style="width:0%"></div>
  </div>
  <!-- Remaining info will appear here -->
  <div id="flightInfo" style="margin-top:8px; font-size:14px; color:#333;"></div>
</div>



    <div class="panel-item">
      <h3>Achievements</h3>
      <div class="badges-container">
      </div>
    </div>

    <div class="panel-item">
      <h3>Stats</h3>
      <ul>
        <li>Poems Submitted: <span id="poemCount"></span></li>
        <li>Total Likes: <span id="likeCount"></span></li>
        <li>Total Comments: <span id="commentCount"></span></li>
      </ul>
    </div>

    <div class="panel-item">
      <h3>3 Top Poems</h3>
      <div class="top-poem">
        <p id="topPoemContent"></p>
      </div>
    </div>

  </div>
</section>

<!-- Fullscreen image modal -->
<div id="imageModal" class="image-modal">
  <span class="close-modal">&times;</span>
  <img class="modal-content" id="expandedImg">
</div>

<!-- POEMS SECTION -->
<div class="profile-poems">
  <h2>My Submitted Poems</h2>
  <!-- üîç Search Bar -->
 <div class="search-bar">
  <input 
    type="text" 
    id="searchInput" 
    placeholder="Search poems..."
    autocomplete="on"
  >
</div>


  <div id="poemsContainer">
    <p class="empty-message"></p>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { 
  getFirestore, doc, getDoc, setDoc, updateDoc, 
  collection, query, where, getDocs, onSnapshot, runTransaction,
  addDoc, deleteDoc  
} from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
import { getStorage } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-storage.js";

const firebaseConfig = {
  apiKey: "AIzaSyC4DHI8aBVY4JjTvJ-r-TGIDPsewtEWxzU",
  authDomain: "silent-depth.firebaseapp.com",
  projectId: "silent-depth",
  storageBucket: "silent-depth.appspot.com",
  messagingSenderId: "78008755450",
  appId: "1:78008755450:web:3fd0f0f298a08820935543"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);
const storage = getStorage(app);

// --- Get ?uid from URL ---
const urlParams = new URLSearchParams(window.location.search);
const profileUid = urlParams.get("uid"); // null if it's your profile

// --- DOM elements ---
const realNameSpan = document.getElementById("realName");
const usernameSpan = document.getElementById("username");
const emailSpan = document.getElementById("email");
const bioSpan = document.getElementById("bio");
const joinedSpan = document.getElementById("joined");
const profilePic = document.getElementById("profilePic");
const logoutBtn = document.getElementById("logoutBtn");
const editBtn = document.getElementById("editProfileBtn");
const changePicBtn = document.getElementById("changePicBtn");
const uploadPic = document.getElementById("uploadPic");
const poemsContainer = document.getElementById("poemsContainer");
const topPoemsContainer = document.getElementById("topPoems");
const rankingContainer = document.getElementById("ranking-poets-container"); // your leaderboard container

let actorUsername = "";   // logged-in user's username (for actions/notifications)
let profileUsername = ""; // the username of the profile being viewed (whose poems we show)
let viewingOwnProfile = false;

// --- Truncate poems by number of lines ---
function truncatePoemByLines(text, maxLines = 8) {
  const lines = text.split(/\r?\n/);
  const truncated = lines.slice(0, maxLines).join("\n");
  return {
    preview: truncated,       // removed the "..." here
    full: text,
    truncated: lines.length > maxLines
  };
}

// --- Update Achievements dynamically ---
async function updateAchievements(poemCount, totalLikes, totalCommentsReceived, totalCommentsMade) {
  const badgesContainer = document.querySelector(".badges-container");
  if (!badgesContainer) return;
  badgesContainer.innerHTML = "";

  // Fetch admin-defined achievements from Firestore
  try {
    const snapshot = await getDocs(collection(db, "achievements"));
    if (!snapshot.empty) {
      const achievements = snapshot.docs.map(docSnap => ({ id: docSnap.id, ...docSnap.data() }));

      // Filter achievements the user qualifies for
      const earned = achievements.filter(a => {
        if (!a.active) return false;
        const { type, min } = a.condition;
        switch(type) {
          case "poemsSubmitted": return poemCount >= min;
          case "likesReceived": return totalLikes >= min;
          case "commentsMade": return totalCommentsMade >= min;
          case "commentsReceived": return totalCommentsReceived >= min;
          default: return false;
        }
      });

      // Append earned badges dynamically
      earned.forEach(badge => {
        const img = document.createElement("img");
        img.src = badge.imageUrl || "https://via.placeholder.com/50"; // fallback image
        img.title = badge.title;
        img.alt = badge.title;
        badgesContainer.appendChild(img);
      });
    }
  } catch (err) {
    console.error("Error loading dynamic achievements:", err);
  }

  // Update level based on activity
  updateLevel(poemCount, totalLikes, totalCommentsReceived, totalCommentsMade);
}

// --- Update Level (user activity-based only) ---

function updateLevel(poemCount, totalLikes, totalCommentsReceived, totalCommentsMade) {
  const levelEl = document.getElementById("userLevel");
  const levelProgressEl = document.getElementById("levelProgress");

  // Ensure remaining info container exists
  let levelInfoEl = document.querySelector(".panel-item .level-info");
  if (!levelInfoEl) {
    levelInfoEl = document.createElement("div");
    levelInfoEl.className = "level-info";
    levelInfoEl.style.marginTop = "8px";
    levelInfoEl.style.fontSize = "14px";
    levelInfoEl.style.color = "#333";
    const panelItem = document.querySelector(".panel-item");
    if (panelItem) panelItem.appendChild(levelInfoEl);
  }

  // Base requirements for first level
  let baseRequirements = {
    poems: 2,
    likes: 2,
    commentsMade: 2,
    commentsReceived: 1
  };

  let level = 1;

  let poems = poemCount;
  let likes = totalLikes;
  let commentsMade = totalCommentsMade;
  let commentsReceived = totalCommentsReceived;

  // Track what‚Äôs left to next level
  let remaining = { poems: 0, likes: 0, commentsMade: 0, commentsReceived: 0 };

  while (true) {
    const poemProgress = poems / baseRequirements.poems;
    const likesProgress = likes / baseRequirements.likes;
    const commentsMadeProgress = commentsMade / baseRequirements.commentsMade;
    const commentsReceivedProgress = commentsReceived / baseRequirements.commentsReceived;

    const levelProgress = Math.min((poemProgress + likesProgress + commentsMadeProgress + commentsReceivedProgress) / 4, 1);

    if (levelProgress >= 1) {
      // Level up
      level++;
      poems -= baseRequirements.poems;
      likes -= baseRequirements.likes;
      commentsMade -= baseRequirements.commentsMade;
      commentsReceived -= baseRequirements.commentsReceived;

      // Increase requirements for next level
      baseRequirements.poems = Math.ceil(baseRequirements.poems * 1.5);
      baseRequirements.likes = Math.ceil(baseRequirements.likes * 1.5);
      baseRequirements.commentsMade = Math.ceil(baseRequirements.commentsMade * 1.5);
      baseRequirements.commentsReceived = Math.ceil(baseRequirements.commentsReceived * 1.5);
    } else {
      // Remaining to next level
      remaining.poems = Math.max(baseRequirements.poems - poems, 0);
      remaining.likes = Math.max(baseRequirements.likes - likes, 0);
      remaining.commentsMade = Math.max(baseRequirements.commentsMade - commentsMade, 0);
      remaining.commentsReceived = Math.max(baseRequirements.commentsReceived - commentsReceived, 0);

      // Set progress bar
      if (levelProgressEl) levelProgressEl.style.width = `${levelProgress * 100}%`;
      break;
    }
  }

  if (levelEl) levelEl.textContent = level;

  if (levelInfoEl) {
    levelInfoEl.innerHTML = `
      <strong>Remaining to next flight:</strong><br>
      Poems: ${remaining.poems}<br>
      Likes: ${remaining.likes}<br>
      Comments Made: ${remaining.commentsMade}<br>
      Comments Received: ${remaining.commentsReceived}
    `;
  }
}

function getInitials(name = "") {
  const parts = name.trim().split(" ");
  if (parts.length === 1) return parts[0][0]?.toUpperCase() || "?";
  return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
}

function colorFromName(name = "") {
  let hash = 0;
  for (let i = 0; i < name.length; i++) {
    hash = name.charCodeAt(i) + ((hash << 5) - hash);
  }
  const hue = Math.abs(hash) % 360;
  return `hsl(${hue}, 60%, 45%)`;
}

// --- Generate a PNG blob of initials with background color ---
function generateAvatarImage(initials, bgColor, size = 180) {
  const canvas = document.createElement("canvas");
  canvas.width = canvas.height = size;
  const ctx = canvas.getContext("2d");

  ctx.fillStyle = bgColor;
  ctx.fillRect(0, 0, size, size);

  ctx.fillStyle = "#ffffff";
  ctx.font = `${size * 0.5}px 'Playfair Display', serif`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(initials, size / 2, size / 2);

  return new Promise(resolve => {
    canvas.toBlob(blob => resolve(blob), "image/png");
  });
}

// --- Upload generated initials image to Cloudinary & update Firestore ---
async function uploadAvatarToCloudinary(initials, bgColor, publicId = null) {
  const blob = await generateAvatarImage(initials, bgColor);

  const formData = new FormData();
  formData.append("file", blob);
  formData.append("upload_preset", "profile_pics"); // must match your Cloudinary preset
  if (publicId) formData.append("public_id", publicId); // overwrite existing image

  const cloudName = "dzoq4pgjn";

  try {
    const res = await fetch(`https://api.cloudinary.com/v1_1/${cloudName}/image/upload`, {
      method: "POST",
      body: formData
    });
    const data = await res.json();
    const imageUrl = data.secure_url;

    // Save for this user only
    const user = auth.currentUser;
    if (user) {
      const userRef = doc(db, "users", user.uid);
      await updateDoc(userRef, { 
        photoURL: imageUrl,          
        cachedAvatarURL: imageUrl    
      });
    }

    return imageUrl;
  } catch (err) {
    console.error("Cloudinary upload failed:", err);
    return null;
  }
}


// --- Auth handling ---
onAuthStateChanged(auth, async (user) => {
  if (!user) {
    window.location.href = "users-login.html";
    return;
  }

  // Fetch actor (logged-in) user's doc to know their username for actions
  const actorRef = doc(db, "users", user.uid);
  let actorDoc = await getDoc(actorRef);
  if (!actorDoc.exists()) {
    await setDoc(actorRef, {
      username: user.displayName || user.email.split("@")[0],
      email: user.email,
      bio: "",
      realName: "",
      joined: new Date(),
      photoURL: user.photoURL || ""
    });
    actorDoc = await getDoc(actorRef);
  }
  const actorData = actorDoc.data();
  actorUsername = actorData.username || user.email.split("@")[0];

  // Determine if we are viewing our own or another user‚Äôs profile
  viewingOwnProfile = !profileUid || profileUid === user.uid;
  const targetUid = viewingOwnProfile ? user.uid : profileUid;

  // Load the target profile's data (profileUsername etc.)
  const userRef = doc(db, "users", targetUid);
  const userDoc = await getDoc(userRef);

  if (!userDoc.exists()) {
    alert("User not found.");
    window.location.href = "index.html";
    return;
  }

  const data = userDoc.data();
  profileUsername = data.username || data.email.split("@")[0];

  if (realNameSpan) realNameSpan.textContent = data.realName || "Not set";
  if (usernameSpan) usernameSpan.textContent = profileUsername;
  if (emailSpan) emailSpan.textContent = data.email || "";
  if (bioSpan) bioSpan.textContent = data.bio || "No bio yet";
  if (joinedSpan) {
    joinedSpan.textContent = data.joined
      ? (data.joined.seconds
          ? new Date(data.joined.seconds * 1000).toDateString()
          : new Date(data.joined).toDateString())
      : "Unknown";
  }
const avatarDiv = document.getElementById("profileAvatar");
const avatarText = document.getElementById("avatarInitials");

if (data.photoURL) {
  profilePic.src = data.photoURL; // uploaded image
  profilePic.style.display = "block";
  avatarDiv.style.display = "none";
} else if (data.cachedAvatarURL) {
  profilePic.src = data.cachedAvatarURL; // cached Cloudinary initials
  profilePic.style.display = "block";
  avatarDiv.style.display = "none";
} else {
  // üîê ONLY generate locally ‚Äî NEVER upload ‚Äî NEVER save
  const initials = getInitials(profileUsername);
  const bgColor = colorFromName(profileUsername);

  avatarText.textContent = initials;
  avatarDiv.style.background = bgColor;
  avatarDiv.style.display = "flex";
  profilePic.style.display = "none";
  if (!viewingOwnProfile) {
  console.warn("Blocked avatar upload: not own profile");
  return null;
}


  uploadAvatarToCloudinary(initials, bgColor).then(url => {
    if (url) {
      profilePic.src = url;
      profilePic.style.display = "block";
      avatarDiv.style.display = "none";
    }
  });
}
const regenerateAvatarBtn = document.getElementById("regenerateAvatarBtn");

if (regenerateAvatarBtn && viewingOwnProfile) {
  regenerateAvatarBtn.style.display = "inline-block";
  regenerateAvatarBtn.addEventListener("click", async () => {
    const initials = getInitials(profileUsername);
    const bgColor = colorFromName(profileUsername);

    try {
      // Use the old photoURL filename (without domain) as public_id to overwrite
      let publicId = null;
      if (profilePic.src) {
        const urlParts = profilePic.src.split("/");
        const filename = urlParts[urlParts.length - 1].split(".")[0]; // remove extension
        publicId = `profile_pics/${filename}`; // assuming folder preset
      }

      const newAvatarUrl = await uploadAvatarToCloudinary(initials, bgColor, publicId);
      if (newAvatarUrl) {
        profilePic.src = newAvatarUrl;
        profilePic.style.display = "block";
        document.getElementById("profileAvatar").style.display = "none";
        alert("‚úÖ Avatar regenerated and replaced successfully!");
      } else {
        alert("‚ùå Failed to regenerate avatar.");
      }
    } catch (err) {
      console.error("Error regenerating avatar:", err);
      alert("‚ùå Something went wrong.");
    }
  });
}

  // If it's someone else's profile ‚Üí disable editing (but still allow likes/comments on poems)
  if (!viewingOwnProfile) {
    if (editBtn) editBtn.style.display = "none";
    if (changePicBtn) changePicBtn.style.display = "none";
    if (uploadPic) uploadPic.style.display = "none";
    document.getElementById("logoutBtn")?.remove();
  }
  if (viewingOwnProfile && editBtn) {
  editBtn.style.display = "inline-block"; // make sure it's visible
  editBtn.addEventListener("click", () => {
    window.location.href = "edit-profile.html";
  });
}

// If it's someone else's profile ‚Üí hide Quick Access menu
if (!viewingOwnProfile) {
  const quickAccessPanel = document.querySelector(".interaction-panel");
  if (quickAccessPanel) {
    quickAccessPanel.style.display = "none";
  }
}

  // Fetch profile's poems and top poems
  await fetchUserPoems(profileUsername);
  await fetchTopPoems(profileUsername);

  // Load ranking poets (optional leaderboard) ‚Äî only once after user loads
  await loadRankingPoets();
});

// --- Fetch User Poems (for profile being viewed) ---
// --- Fetch User Poems (for profile being viewed) - SORTED IN MEMORY (NO INDEX NEEDED) ---
async function fetchUserPoems(usernameToFetch) {
  try {
    // Simple query without orderBy - just filter by username
    const q = query(
      collection(db, "recentPoems"), 
      where("submittedBy", "==", usernameToFetch)
      // No orderBy here to avoid index requirement
    );
    
    const querySnap = await getDocs(q);
    const container = poemsContainer;
    container.innerHTML = "";

    let totalLikes = 0;
    let totalCommentsReceived = 0;
    let poemCount = querySnap.size;
    let totalCommentsMade = 0;

    if (querySnap.empty) {
      container.innerHTML = `<p class="empty-message">No poems yet.</p>`;
    } else {
      // Convert to array and sort by timestamp in memory
      const poemsArray = [];
      
      for (const docSnap of querySnap.docs) {
        const poem = docSnap.data();
        poem.id = docSnap.id; // Store the ID
        poemsArray.push(poem);
      }
      
      // Sort by timestamp descending (most recent first) in memory
      poemsArray.sort((a, b) => {
        const timeA = a.timestamp?.seconds || 0;
        const timeB = b.timestamp?.seconds || 0;
        return timeB - timeA; // Descending order
      });
      
      // Now render the sorted poems
      for (const poem of poemsArray) {
        const docId = poem.id;
        const card = document.createElement("div");
        card.className = "recent-poem-card";
        card.dataset.id = docId;

        const truncated = truncatePoemByLines(poem.content, 8);
        const likes = typeof poem.likes === "number" ? poem.likes : 0;
        totalLikes += likes;

        let commentsSnapCount = 0;
        try {
          const commentsSnap = await getDocs(collection(db, "recentPoems", docId, "comments"));
          commentsSnapCount = commentsSnap.size;
        } catch (err) {
          commentsSnapCount = Array.isArray(poem.comments) ? poem.comments.length : 0;
        }
        totalCommentsReceived += commentsSnapCount;

        const authorLink = poem.submittedByUid
          ? `<a href="user-profile.html?uid=${encodeURIComponent(poem.submittedByUid)}" class="author-link">${poem.author || poem.submittedBy || usernameToFetch}</a>`
          : `<a href="user-profile.html?user=${encodeURIComponent(poem.submittedBy || usernameToFetch)}" class="author-link">${poem.author || poem.submittedBy || usernameToFetch}</a>`;

        const dateStr = poem.timestamp 
          ? new Date(poem.timestamp.seconds * 1000).toLocaleDateString() + ' ' + new Date(poem.timestamp.seconds * 1000).toLocaleTimeString()
          : "";

card.innerHTML = `
 <div class="poem-display">
  <h3 class="poem-title">${poem.title}</h3>
  ${dateStr ? `<small class="poem-date">${dateStr}</small>` : ""}
  <button class="delete-btn">üóëÔ∏è Delete</button>
  <div class="poem-body">
    <p class="poem-content">${truncated.preview.replace(/\n/g, "<br>")}</p>
    ${truncated.truncated ? `<button class="read-more-btn">Show More</button>` : ""}
  </div>
</div>

  ${poem.categories && poem.categories.length > 0 ? `<p class="poem-category-line"><em>${poem.categories.join(", ")}</em></p>` : ""}
  <div class="poem-actions comment-aligned">
    <textarea class="comment-input" placeholder="Write a comment..." rows="1"></textarea>
    <button class="comment-btn">Post</button>
    <button class="like-btn">
      ‚ù§Ô∏è <span class="like-count">${likes}</span>
    </button>
    <span class="message-count">üí¨ ${commentsSnapCount}</span>
  </div>
  <div class="comment-list" style="display:none;"></div>
`;

if (viewingOwnProfile) {
  const deleteBtn = document.createElement("button");
  deleteBtn.className = "delete-btn";
  deleteBtn.textContent = "üóëÔ∏è Delete";
  deleteBtn.style.marginLeft = "8px";
  card.querySelector(".poem-actions").appendChild(deleteBtn);
}

const deleteBtn = card.querySelector(".delete-btn");
if (viewingOwnProfile) {
  deleteBtn.style.display = "inline-block";
} else {
  deleteBtn.style.display = "none";
}

  container.appendChild(card);
      }
    }

    const poemCountEl = document.getElementById("poemCount");
    const likeCountEl = document.getElementById("likeCount");
    const commentCountEl = document.getElementById("commentCount");
    if (poemCountEl) poemCountEl.textContent = poemCount;
    if (likeCountEl) likeCountEl.textContent = totalLikes;
    if (commentCountEl) commentCountEl.textContent = totalCommentsReceived;

    updateAchievements(poemCount, totalLikes, totalCommentsReceived, totalCommentsMade);
    updateLevel(poemCount, totalLikes, totalCommentsReceived, totalCommentsMade);
  } catch (err) {
    console.error("Error fetching poems:", err);
    poemsContainer.innerHTML = `<p class='empty-message'>Error loading poems: ${err.message}</p>`;
  }
}

// üíå Helper: Add notification for the poem owner
async function addNotification(poemId, poemOwnerUid, type, fromUser, text = "") {
  if (!poemOwnerUid || !auth.currentUser) return; // don't notify if missing
  if (poemOwnerUid === auth.currentUser.uid) return; // don't notify self

  const userRef = doc(db, "users", poemOwnerUid);
  try {
    await runTransaction(db, async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists()) return;

      const data = userSnap.data();
      const notifications = Array.isArray(data.notifications) ? data.notifications : [];

      notifications.push({
        type,               // "like" or "comment"
        from: fromUser,     // username of the actor
        poemId,             // which poem
        text,               // comment text (if any)
        read: false,
        timestamp: new Date()
      });

      tx.update(userRef, { notifications });
    });
  } catch (err) {
    console.error("Failed to add notification:", err);
  }
}

// ‚úÖ Unified click listener for poems container (likes, comments, read more)
poemsContainer.addEventListener("click", async (e) => {
  const card = e.target.closest(".recent-poem-card");
  if (!card) return;
  const poemId = card.dataset.id;
  if (!poemId) return;

  const currentUser = auth.currentUser;

// DELETE POEM
if (e.target.classList.contains("delete-btn")) {
  if (!confirm("Are you sure you want to delete this poem?")) return;

  try {
    await deleteDoc(doc(db, "recentPoems", poemId));
    card.remove(); // remove from DOM instantly
    alert("Poem deleted successfully!");
  } catch (err) {
    console.error("Failed to delete poem:", err);
    alert("Failed to delete poem.");
  }
}


  // ‚ù§Ô∏è LIKE BUTTON ‚Äî each user can like only once
  if (e.target.classList.contains("like-btn")) {
    const likeBtn = e.target;
    const countEl = card.querySelector(".like-count");
    if (!countEl) return;

    if (!currentUser) {
      alert("Please sign in to like poems.");
      return;
    }
    const userUid = currentUser.uid;
    likeBtn.disabled = true;
    const prevText = likeBtn.textContent;

    try {
      const poemRef = doc(db, "recentPoems", poemId);
      await runTransaction(db, async (tx) => {
        const snap = await tx.get(poemRef);
        if (!snap.exists()) throw new Error("DOC_NOT_FOUND");

        const data = snap.data();
        const likedBy = Array.isArray(data.likedBy) ? data.likedBy : [];
        const currentLikes = typeof data.likes === "number" ? data.likes : 0;

        if (likedBy.includes(userUid)) throw new Error("ALREADY_LIKED");

        tx.update(poemRef, {
          likes: currentLikes + 1,
          likedBy: [...likedBy, userUid],
        });
      });

      const prevCount = parseInt(countEl.textContent) || 0;
      countEl.textContent = prevCount + 1;
      likeBtn.classList.add("liked");
      likeBtn.textContent = "‚ù§Ô∏è Liked";
      likeBtn.style.pointerEvents = "none";

      // Add notification for poem owner
      const poemSnap = await getDoc(doc(db, "recentPoems", poemId));
      const poemOwner = poemSnap.data().submittedByUid || poemSnap.data().uid;
      await addNotification(poemId, poemOwner, "like", actorUsername);

    } catch (err) {
      console.error("Like transaction failed:", err);

      if (err.message === "ALREADY_LIKED") {
        likeBtn.classList.add("liked");
        likeBtn.textContent = "‚ù§Ô∏è Liked";
        likeBtn.style.pointerEvents = "none";
        alert("You‚Äôve already liked this poem.");
      } else if (err.message === "DOC_NOT_FOUND") {
        alert("This poem no longer exists.");
      } else if (err.code === "permission-denied") {
        alert("You don't have permission to like this poem (security rules).");
      } else {
        alert("Could not like the poem. Try again.");
      }

      if (err.message !== "ALREADY_LIKED") {
        likeBtn.disabled = false;
        likeBtn.textContent = prevText;
      }
    }
  }
// SHOW COMMENTS
if (e.target.classList.contains("message-count")) {
  const card = e.target.closest(".recent-poem-card");
  const docId = card.dataset.id;
  const commentList = card.querySelector(".comment-list");

  // Toggle visibility
  const isVisible = commentList.style.display === "block";
  commentList.style.display = isVisible ? "none" : "block";
  if (isVisible) return;

  commentList.innerHTML = "<p style='color:#888;'>Loading comments...</p>";

  try {
    const commentsCol = collection(db, "recentPoems", docId, "comments");
    const commentsSnapshot = await getDocs(commentsCol);
    commentList.innerHTML = ""; // clear loading text

    if (commentsSnapshot.empty) {
      commentList.innerHTML = "<p style='color:#888;'>No comments yet.</p>";
      return;
    }

    // Get poem owner ID
    const poemRef = doc(db, "recentPoems", docId);
    const poemSnap = await getDoc(poemRef);
    const poemOwnerId = poemSnap.exists() ? poemSnap.data().authorId || poemSnap.data().userId : null;

    // Sort comments by timestamp ascending
    const comments = commentsSnapshot.docs.map(d => ({ id: d.id, ...d.data() }));
    comments.sort((a, b) => {
      const ta = a.timestamp?.toMillis?.() || 0;
      const tb = b.timestamp?.toMillis?.() || 0;
      return ta - tb;
    });

    // Display comments
    for (const c of comments) {
      let displayName = c.user || "Anonymous";
      let userLink = "#";
      if (c.userId) {
        try {
          const userDoc = await getDoc(doc(db, "users", c.userId));
          if (userDoc.exists()) {
            displayName = userDoc.data().username || displayName;
            userLink = `/user-profile.html?uid=${c.userId}`;
          }
        } catch {}
      }

      const div = document.createElement("div");
      div.className = "comment";
      div.dataset.commentId = c.id;
      div.style.cssText = "background:#fff; padding:8px 12px; margin:6px 0; border-radius:6px;";

      div.innerHTML = `
        <a href="${userLink}" style="font-weight:600; color:#a67c52; text-decoration:none; margin-right:6px;">${displayName}</a>: ${c.text}
        <div class="comment-actions" style="margin-top:4px;">
          <small class="reply-toggle" style="color:#5a3cb3; cursor:pointer;">Reply</small>
        </div>
        <div class="reply-section" style="margin-left:20px; margin-top:6px;"></div>
      `;

      commentList.appendChild(div);

      // Load existing replies
      const repliesCol = collection(db, "recentPoems", docId, "comments", c.id, "replies");
      const repliesSnapshot = await getDocs(repliesCol);
      if (!repliesSnapshot.empty) {
        const replySection = div.querySelector(".reply-section");
        repliesSnapshot.forEach(r => {
          const reply = r.data();
          replySection.innerHTML += `
            <div style="background:#f7f7f7; padding:6px 10px; border-radius:6px; margin:4px 0;">
              <a href="/user-profile.html?uid=${reply.userId}" style="font-weight:600; color:#5a3cb3; text-decoration:none;">${reply.username}</a>: ${reply.text}
            </div>
          `;
        });
      }
    }
  } catch (err) {
    console.error("Error loading comments:", err);
    commentList.innerHTML = "<p style='color:red;'>Failed to load comments.</p>";
  }
}

// REPLY TOGGLE ‚Äî show input box when ‚ÄúReply‚Äù is clicked
if (e.target.classList.contains("reply-toggle")) {
  const commentDiv = e.target.closest(".comment");
  const replySection = commentDiv.querySelector(".reply-section");

  // If already open, close it
  const existing = replySection.querySelector(".reply-input");
  if (existing) {
    existing.remove();
    return;
  }

  const inputContainer = document.createElement("div");
  inputContainer.className = "reply-input";
  inputContainer.innerHTML = `
    <textarea placeholder="Write a reply..." rows="1" style="width:95%; border-radius:6px; padding:6px; border:1px solid #ccc;"></textarea>
    <button class="send-reply-btn" style="margin-top:4px; background:#5a3cb3; color:white; border:none; border-radius:6px; padding:4px 10px; cursor:pointer;">Send</button>
  `;
  replySection.appendChild(inputContainer);
}

// SEND REPLY ‚Äî handle send button click
// SEND REPLY ‚Äî handle send button click
if (e.target.classList.contains("send-reply-btn")) {
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in to reply.");
    return;
  }

  const commentDiv = e.target.closest(".comment");
  const card = e.target.closest(".recent-poem-card");
  const docId = card.dataset.id;
  const commentId = commentDiv.dataset.commentId;
  const textarea = commentDiv.querySelector(".reply-input textarea");
  const replyText = textarea.value.trim();
  if (!replyText) return;

  const replySection = commentDiv.querySelector(".reply-section");

  try {
    // Fetch username of current user
    const userDoc = await getDoc(doc(db, "users", user.uid));
    const username = userDoc.exists() ? userDoc.data().username || "User" : "User";

    // Add reply to Firestore
    await addDoc(collection(db, "recentPoems", docId, "comments", commentId, "replies"), {
      userId: user.uid,
      username,
      text: replyText,
      timestamp: new Date()
    });

    // Append instantly to UI
    const replyDiv = document.createElement("div");
    replyDiv.style.cssText = "background:#f7f7f7; padding:6px 10px; border-radius:6px; margin:4px 0;";
    replyDiv.innerHTML = `
      <a href="/user-profile.html?uid=${user.uid}" style="font-weight:400; color:#5a3cb3; text-decoration:none;">
        ${username}
      </a>: ${replyText}
    `;
    replySection.appendChild(replyDiv);

    // Clear textarea
    textarea.value = "";

  } catch (err) {
    console.error("Error sending reply:", err);
    alert("Failed to send reply.");
  }
}

// üìù POST COMMENT
if (e.target.classList.contains("comment-btn")) {
  const input = card.querySelector(".comment-input");
  const text = input.value.trim();
  if (!text) return alert("Comment cannot be empty.");

  if (!auth.currentUser) {
    alert("Please sign in to comment.");
    return;
  }

  try {
    const commentsRef = collection(db, "recentPoems", poemId, "comments");
    const newCommentRef = doc(commentsRef); // generate new doc
    await setDoc(newCommentRef, {
      text,
      user: actorUsername,
      userId: auth.currentUser.uid,
      createdAt: new Date(),
    });

    input.value = "";
    const messageCount = card.querySelector(".message-count");
    const currentCount =
      parseInt((messageCount?.textContent || "").replace("üí¨", "")) || 0;
    if (messageCount) messageCount.textContent = `üí¨ ${currentCount + 1}`;

    const commentList = card.querySelector(".comment-list");
    if (commentList.style.display === "block") {
      // append new comment in the same structure as existing comments
      const div = document.createElement("div");
      div.className = "comment";
      div.dataset.commentId = newCommentRef.id;
      div.style.cssText = "background:#fff; padding:8px 12px; margin:6px 0; border-radius:6px;";
      div.innerHTML = `
        <a href="/user-profile.html?uid=${auth.currentUser.uid}" style="font-weight:600; color:#a67c52; text-decoration:none; margin-right:6px;">${actorUsername}</a>: ${text}
        <div class="comment-actions" style="margin-top:4px;">
          <small class="reply-toggle" style="color:#5a3cb3; cursor:pointer;">Reply</small>
        </div>
        <div class="reply-section" style="margin-left:20px; margin-top:6px;"></div>
      `;
      commentList.appendChild(div);
    }

    // Add notification for poem owner
    const poemSnap = await getDoc(doc(db, "recentPoems", poemId));
    const poemOwner = poemSnap.data().submittedByUid || poemSnap.data().uid;
    await addNotification(poemId, poemOwner, "comment", actorUsername, text);

  } catch (err) {
    console.error("Error posting comment:", err);
    alert("Failed to post comment.");
  }
}


  // üëÅÔ∏è READ MORE toggle
  if (e.target.classList.contains("read-more-btn")) {
    const poemBody = card.querySelector(".poem-body");
    const poemContent = poemBody.querySelector(".poem-content");
    const isExpanded = e.target.textContent.includes("Less");

    const poemSnap = await getDoc(doc(db, "recentPoems", poemId));

    if (isExpanded) {
      const truncated = truncatePoemByLines(poemSnap.data().content, 8);
      poemContent.textContent = truncated.preview;
      e.target.textContent = "Show More";
    } else {
      poemContent.textContent = poemSnap.data().content;
      e.target.textContent = "Show Less";
    }
  }
});

// --- Fetch Top 3 Poems for this profile (clickable + numbering) ---
async function fetchTopPoems(profileName) {
  try {
    if (!profileName) return;

    const poemsRef = collection(db, "recentPoems");
    const q = query(poemsRef, where("submittedBy", "==", profileName));
    const snapshot = await getDocs(q);

    const topPoemContent = document.getElementById("topPoemContent");
    if (!topPoemContent) return;

    if (snapshot.empty) {
      topPoemContent.textContent = "No poems yet.";
      return;
    }

    const poems = [];

    snapshot.forEach((docSnap) => {
      const poem = docSnap.data();
      if (!poem.title) return;

      const likes = poem.likes || 0;
      const comments = Array.isArray(poem.comments) ? poem.comments.length : 0;
      const engagement = likes + comments;

      const slug = poem.slug || poem.title.toLowerCase().replace(/\s+/g, "-").replace(/[^\w-]+/g, "");
      poems.push({ slug, title: poem.title, engagement });
    });

    const top3 = poems.sort((a, b) => b.engagement - a.engagement).slice(0, 3);

    topPoemContent.innerHTML = top3.length
      ? top3
          .map(
            (p, i) =>
              `<div style="margin-bottom:4px;">
                <span style="display:inline;">${i + 1}.</span>
                <a href="poem.html?slug=${encodeURIComponent(p.slug)}" class="top-poem-link" style="display:inline;">${p.title}</a>
              </div>`
          )
          .join("")
      : "No top poems yet.";
  } catch (error) {
    console.error("Error fetching top poems:", error);
  }
}


// --- Cloudinary Upload (only for your own profile) ---
if (changePicBtn) {
  const cloudName = "dzoq4pgjn"; // your Cloudinary cloud name
  const uploadPreset = "profile_pics"; // must match your Cloudinary preset

  changePicBtn.addEventListener("click", () => {
    if (!viewingOwnProfile) return alert("You cannot change another user's picture.");
    uploadPic.click();
  });

  uploadPic.addEventListener("change", async (e) => {
    if (!viewingOwnProfile) return;
    const file = e.target.files[0];
    if (!file) return;

    const formData = new FormData();
    formData.append("file", file);
    formData.append("upload_preset", uploadPreset);

    try {
      const res = await fetch(`https://api.cloudinary.com/v1_1/${cloudName}/image/upload`, {
        method: "POST",
        body: formData
      });
      const data = await res.json();
      const imageUrl = data.secure_url.replace(
        '/upload/',
        '/upload/c_fill,g_auto,f_auto,q_auto:best,h_600,w_600,r_max,e_sharpen/'
      );

      // Update image instantly
      if (profilePic) profilePic.src = imageUrl;

      // Save to Firestore for persistence
      const user = auth.currentUser;
      if (user) {
        await updateDoc(doc(db, "users", user.uid), { photoURL: imageUrl });
      }

      console.log("‚úÖ Uploaded to Cloudinary:", imageUrl);
    } catch (err) {
      console.error("‚ùå Cloudinary upload error:", err);
    }
  });
}

// --- Profile picture expand on click ---
const modal = document.getElementById("imageModal");
const expandedImg = document.getElementById("expandedImg");
const closeModal = document.querySelector(".close-modal");
const profilePicEl = document.getElementById("profilePic");
if (profilePicEl) {
  profilePicEl.addEventListener("click", () => {
    if (expandedImg) expandedImg.src = profilePicEl.src;
    if (modal) modal.style.display = "flex";
  });
}
if (closeModal) {
  closeModal.addEventListener("click", () => {
    if (modal) modal.style.display = "none";
  });
}
window.addEventListener("click", (e) => {
  if (e.target === modal) modal.style.display = "none";
});

// Menu toggle and nav
const menuToggle = document.getElementById("menu-toggle");
const navLinks = document.getElementById("nav-links");
const closeBtn = document.getElementById("close-btn");

if (menuToggle) {
  menuToggle.addEventListener("click", () => {
    navLinks.classList.toggle("show");
  });
}
if (closeBtn) {
  closeBtn.addEventListener("click", () => {
    navLinks.classList.remove("show");
  });
}
// --- Logout Nav Button ---
const logoutBtnNav = document.getElementById("logoutBtnNav");
if (logoutBtnNav) {
  logoutBtnNav.addEventListener("click", async () => {
    if (!auth.currentUser) {
      alert("No user is logged in.");
      return;
    }
    try {
      await signOut(auth); // properly sign out
      window.location.href = "users-login.html";
    } catch (err) {
      console.error("Logout failed:", err);
      alert("Logout failed, try again.");
    }
  });
}

// --- Search Filter with Firestore ---
const searchInput = document.getElementById("searchInput");
let debounceTimeout;

// Keep track of poems already in the DOM to avoid duplicates
const loadedPoemIds = new Set(
  Array.from(document.querySelectorAll(".recent-poem-card")).map(
    card => card.dataset.id
  )
);

if (searchInput) {
  searchInput.addEventListener("input", () => {
    clearTimeout(debounceTimeout);
    debounceTimeout = setTimeout(async () => {
      const filter = searchInput.value.trim().toLowerCase();
      filterDOM(filter);
      await searchFirestore(filter);
    }, 300);
  });
}

// --- Filter poems already in the DOM ---
function filterDOM(filter) {
  const cards = document.querySelectorAll(".recent-poem-card");
  let anyVisible = false;

  cards.forEach(card => {
    const title = card.querySelector(".poem-title")?.textContent.toLowerCase() || "";
    const content = card.querySelector(".poem-content")?.textContent.toLowerCase() || "";
    const categories = (card.dataset.categories || "").toLowerCase();

    if (title.includes(filter) || content.includes(filter) || categories.includes(filter)) {
      card.style.display = "block";
      anyVisible = true;
    } else {
      card.style.display = "none";
    }
  });

  showEmptyMessage(!anyVisible);
}

// --- Firestore search ---
async function searchFirestore(filter) {
  if (!filter) return;

  const poemsRef = collection(db, "recentPoems");
  const snapshot = await getDocs(poemsRef);

  let anyNewResults = false;

  snapshot.docs.forEach(docSnap => {
    const data = docSnap.data();
    const id = docSnap.id;

    // Skip poems already in the DOM
    if (loadedPoemIds.has(id)) return;

    const title = (data.title || "").toLowerCase();
    const content = (data.content || "").toLowerCase();
    const categories = (data.categories || "").toLowerCase();

    if (title.includes(filter) || content.includes(filter) || categories.includes(filter)) {
      addPoemCardToDOM(id, data);
      loadedPoemIds.add(id);
      anyNewResults = true;
    }
  });

  // Update empty message if no poems visible
  const anyVisible = document.querySelectorAll(".recent-poem-card:not([style*='display: none'])").length > 0;
  showEmptyMessage(!anyVisible);
}

// --- Helper: add new poem card to DOM ---
function addPoemCardToDOM(id, data) {
  const container = document.getElementById("poemsContainer"); // make sure this ID matches your container
  if (!container) return;
  const card = document.createElement("div");
  card.className = "recent-poem-card";
  card.dataset.id = id;
  card.dataset.categories = data.categories || "";

  card.innerHTML = `
    <h3 class="poem-title">${data.title || ""}</h3>
    <p class="poem-content">${data.content || ""}</p>
  `;

  container.appendChild(card);
}

// --- Helper: show/hide empty message ---
function showEmptyMessage(show) {
  const container = document.getElementById("poemsContainer");
  if (!container) return;
  let msg = container.querySelector(".empty-message");
  if (show) {
    if (!msg) {
      msg = document.createElement("p");
      msg.className = "empty-message";
      container.appendChild(msg);
    }
    msg.textContent = "No poems match your search.";
  } else if (msg) {
    msg.textContent = "";
  }
}
</script>


</body>
</html>