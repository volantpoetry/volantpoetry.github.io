<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Profile | Volant Poetry</title>

<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@500;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@700&display=swap" rel="stylesheet">
  
<link rel="stylesheet" href="style.css" />
<link rel="icon" type="image/png" href="images/logo.png" />
<link rel="apple-touch-icon" href="images/logo.png" />

<style>
:root {
  --primary: #4b2aad;
  --bg: #f7f5ff;
  --text: #1a1a1a;
  --muted: #666;
  --radius: 14px;
}

body {
  font-family: 'Inter', sans-serif;
  background: var(--bg);
  color: var(--text);
  margin: 0;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
}

header {
  width: 100%;
}

/* Profile Section */
.profile-container {
  background: #fff;
  padding: 2rem;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  width: 90%;
  max-width: 500px;
  text-align: center;
  margin-top: 40px;
}

.profile-container h2 { color: var(--primary); margin-bottom: 1rem; }

.profile-picture img {
  width: 100px;
  height: 100px;
  border-radius: 50%;
  object-fit: cover;
  margin-bottom: 0.8rem;
  border: 3px solid var(--primary);
}

.profile-info { margin: 1rem 0; font-size: 1rem; color: #333; }
.profile-info p { margin: 0.5rem 0; }

.btn {
  padding: 0.5rem 1rem;
  background: var(--primary);
  color: #fff;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: 0.2s;
  margin-top: 0.5rem;
}

.btn:hover { background: #6c3ddd; }

#editProfileBtn { background: #fff; color: var(--primary); border: 1px solid var(--primary); }
#editProfileBtn:hover { background: var(--primary); color: #fff; }

/* Poems Section */
.profile-poems {
  width: 100%;
  max-width: 900px;
  margin: 40px auto;
  transform: translateX(40px);
}

h2 {
  text-align: center;
  font-family: 'Playfair Display', serif;
  font-weight: 600;
  margin: 20px auto 30px auto;
  color: #4b2aad;
}

.profile-poems h3 {
  color: var(--primary);
  text-align: left;
  font-family: 'Playfair Display', serif;
  margin-bottom: 1.5rem;
}

.recent-poem-card {
  background: linear-gradient(160deg, #fdf6f0, #e2e9f0);
  color: #4b3f2f;
  border-radius: 12px;
  padding: 1.2rem;
  margin-bottom: 2rem;
}
/* Center on small screens */
@media (max-width: 768px) {
  .recent-poem-card {
    margin-left: -5;
    margin-right: auto;
    width: 100%; /* optional: make it responsive */
  }
}
.poem-content {
  white-space: pre-wrap;
  line-height: 1.7;
  overflow: hidden;
    padding-left: 12px; /* moves text slightly to the right */
}

/* --- Force smaller comment box --- */
.recent-poem-card .comment-section {
  display: flex;
  align-items: center;
  justify-content: flex-start;
  gap: 8px;
}

.recent-poem-card .comment-input {
  flex: none !important;        /* stop auto-stretching */
  width: 220px !important;      /* fixed smaller width */
  max-width: 65% !important;    /* optional safety */

}
/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Desktop Layout (Two-Column) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
@media (min-width: 900px) {
  .profile-layout {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 40px;
    width: 90%;
    max-width: 1100px;
    margin-top: 50px;
  }

  .profile-container {
    max-width: 100%;
    margin: 0;
    text-align: left;
  }

  .profile-container h2 {
    text-align: left;
  }

  .interaction-panel {
    background: #fff;
    border-radius: 12px;
    box-shadow: 0 3px 10px rgba(0,0,0,0.08);
    padding: 1.5rem;
    height: fit-content;
  }

  .interaction-panel h3 {
    font-family: 'Playfair Display', serif;
    color: var(--primary);
    font-weight: 600;
    margin-bottom: 1rem;
  }

  .interaction-panel ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .interaction-panel li {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 0;
    border-bottom: 1px solid #eee;
    cursor: pointer;
    transition: 0.2s;
  }

  .interaction-panel li:hover {
    color: var(--primary);
    background: #f7f5ff;
    border-radius: 8px;
    padding-left: 10px;
  }
}

/* Poem section stays full width below both columns */
.profile-poems {
  grid-column: 1 / span 2;
  width: 90%;
  max-width: 1100px;
  margin-top: 50px;
  transform: none;
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Search Bar Styling ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Search Bar Styling ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.search-bar {
  display: flex;
  align-items: center;
  justify-content: flex-end; /* Move to right */
  gap: 10px;
  margin: 20px auto 30px;
  width: 100%;              /* Full width container */
  max-width: 900px;         /* Keeps it aligned with your cards */
  padding-right: 50px;      /* Push in from right edge */
}

.search-bar input {
  flex: 0 1 250px;          /* Fixed input width but still responsive */
  padding: 10px 14px;
  font-size: 15px;
  border: 1px solid #ddd;
  border-radius: var(--radius);
  outline: none;
  transition: 0.2s;
  background: #fff;
}

.search-bar input:focus {
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(75, 42, 173, 0.1);
}
.search-bar {
  display: flex;
  justify-content: flex-end;
  align-items: center;
  margin: 10px 0 20px;
  width: 100%;
  padding-right: 15px; /* tighter spacing */
}

.search-bar input {
  width: 150px;               /* smaller width */
  padding: 6px 10px;          /* reduced height */
  font-size: 14px;            /* slightly smaller text */
  border: 1px solid #ccc;
  border-radius: 10px;        /* cute rounded shape */
  outline: none;
  transition: 0.2s;
  background: #fafafa;        /* soft cute look */
}

/* Cute hover & focus effect */
.search-bar input:focus {
  border-color: #999;
  background: #fff;
  box-shadow: 0 0 4px rgba(0,0,0,0.1);
}


.search-bar input:focus {
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(75, 42, 173, 0.1);
}
@media (max-width: 600px) {
  .search-bar {
    width: 50%;             /* narrower on small screens */
    margin-left: auto;      /* push container to the right */
    justify-content: flex-end;
    padding-right: 10px;
  }

  .search-bar input {
    width: 50px !important; /* force small width */
    padding: 5px 8px;
    font-size: 12px;
  }
}

/* Flex container for profile picture + info */
.profile-header-flex {
  display: flex;
  flex-direction: column; /* stack on mobile */
  align-items: center;
  gap: 20px;
}

/* Profile picture section with followers below */
.profile-picture-section {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.follow-info-horizontal {
  display: flex;
  justify-content: center;
  gap: 20px;
  margin-top: 10px;
}

.follow-item {
  text-align: center;
}

/* Profile info on the right */
.profile-info-right {
  display: flex;
  flex-direction: column;
  gap: 10px;
  text-align: left;
    line-height: 0.95; /* tighten lines */
      margin-left: 10px; /* move closer to the profile picture */
}
.profile-info-right p {
  margin: 4px 0; /* small vertical spacing between lines */
}

/* Desktop layout */
@media (min-width: 900px) {
  .profile-header-flex {
    flex-direction: row; /* picture on left, info on right */
    align-items: flex-start;
  }

  .profile-picture-section {
    align-items: center;
  }

  .profile-info-right {
    margin-left: 40px; /* space between picture and info */
  }
}
@media (min-width: 900px) {
  .profile-info-right {
    margin-left: 20px; /* tighter spacing on desktop */
  }
}
/* Move followers/following to the left on desktop */
@media (min-width: 900px) {
  .follow-info-horizontal {
    justify-content: flex-start; /* align to the left instead of center */
    margin-left: 0;              /* remove extra margin if any */
  }
}
.interaction-panel ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.interaction-panel li {
  padding: 10px 0;
  border-bottom: 1px solid #eee;
}

.interaction-panel li a {
  display: flex;
  align-items: center;
  gap: 10px;
  text-decoration: none;  /* remove underline */
  color: var(--text);
  width: 100%;
  transition: 0.2s;
}

.interaction-panel li a:hover {
  color: var(--primary);
  background: #f7f5ff;
  border-radius: 8px;
  padding-left: 10px;
}
/* Full-width horizontal profile stats */
.profile-stats-section {
  width: 100%;               /* Take full page width */
  background: #fff;          /* Optional background */
  padding: 20px 40px;        /* Some spacing */
  margin: 40px 0;            /* Top & bottom spacing */
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  display: flex;
  gap: 30px;                 /* Space between panels */
  overflow-x: auto;          /* Allow horizontal scrolling if screen is small */
  box-sizing: border-box;    /* Include padding in width */
}

/* Each panel item inside stats */
.interaction-panel-horizontal {
  display: flex;
  gap: 40px;
}

.panel-item {
  min-width: 200px;          /* Ensure panels don‚Äôt collapse */
  flex: 1;                   /* Equal width stretch */
  background: #f7f5ff;       /* Optional distinct background */
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.05);
}

/* Level bar */
.level-bar {
  width: 100%;
  height: 12px;
  background: #ddd;
  border-radius: 6px;
  margin-top: 8px;
}
#levelProgress {
  height: 100%;
  background: var(--primary);
  border-radius: 6px;
}


/* Make sure the horizontal profile stats are responsive */
.profile-stats-section {
  width: 100%;
  background:  #f7f5ff;
  padding: 20px 40px;
  margin: 40px 0;
  box-shadow: 0 4px 12px  #f7f5ff;
  display: flex;
  overflow-x: auto;
  gap: 30px;
  box-sizing: border-box;
}

.interaction-panel-horizontal {
  display: flex;
  gap: 30px;
}

.panel-item {
  min-width: 220px;
  flex: 1;
  background: #f7f5ff;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 2px 8px  #B8860B;
}

.badges-container {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-top: 10px;
}

.badges-container img {
  width: 50px;
  height: 50px;
  border-radius: 0;  /* No circles - square/rectangular as in your gallery */
  object-fit: cover;
  border: none;  /* No border */
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  transition: transform 0.2s, box-shadow 0.2s;
  cursor: pointer;
  display: inline-block;
}

.badges-container img:hover {
  transform: scale(1.1);
  box-shadow: 0 4px 12px rgba(75, 42, 173, 0.3);
}

/* Shift the profile layout slightly to the right */
.profile-layout {
  margin-left: 40px; /* adjust px as needed */
}

/* Shift the horizontal stats section to the right as well */
.profile-stats-section {
  margin-left: 70px; /* match the layout shift */
  margin-right: 40px; /* optional: keeps spacing consistent on the right */
}

/* Optional: shift poems section as well */
.profile-poems {
  margin-left: 40px; /* aligns poems with profile layout */
  margin-right: 40px; 
}

.top-poem-link {
  display: block;
  color:  #B8860B;
  text-decoration: none;
  margin: 6px 0;
  font-weight: 600;
  transition: color 0.2s ease;
}

.top-poem-link:hover {
  color: #1a73e8;
}
.profile-picture img {
  width: 180px;           /* üî• bigger circle size */
  height: 180px;
  border-radius: 50%;
  object-fit: cover;
  object-position: center;
  border: 4px solid #ccc;
  box-shadow: 0 0 15px rgba(0,0,0,0.15);
  image-rendering: high-quality;
  transition: transform 0.3s ease;
}

.profile-picture img:hover {
  transform: scale(1.05); /* subtle hover zoom for polish */
}


/* --- Image Modal --- */
.image-modal {
  display: none; /* Hidden by default */
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0,0,0,0.85);
  backdrop-filter: blur(3px);
  align-items: center;
  justify-content: center;
}

.image-modal img {
  max-width: 90%;
  max-height: 90%;
  border-radius: 12px;
  box-shadow: 0 0 30px rgba(255,255,255,0.2);
  animation: zoomIn 0.3s ease;
}

.close-modal {
  position: absolute;
  top: 20px;
  right: 40px;
  color: white;
  font-size: 40px;
  font-weight: bold;
  cursor: pointer;
  transition: 0.2s;
}

.close-modal:hover {
  color: #ff6666;
}

@keyframes zoomIn {
  from { transform: scale(0.9); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}
#topPoemContent span {
  display: block;
  margin-bottom: 4px;
}

.logout-nav-btn {
  display: inline-block;
  margin-left: 20px;
  padding: 6px 12px;
  font-size: 14px;
  background: var(--primary);
  color: #fff;
  border-radius: 8px;
  border: none;
  cursor: pointer;
  z-index: 50; /* ensure it‚Äôs above other elements */
}

.logout-nav-btn:hover {
  background: #6c3ddd;
}

.nav-right {
  display: flex;
  align-items: center;
  gap: 10px;
}
/* Move "My Profile" to left edge on small screens */
@media (max-width: 899px) {
  .profile-container {

 
    text-align: left;   /* align text left */
        width: 80%;         /* full width */
           font-size: 0.9rem; /* smaller text */
             background-color: #4b2aad; /* new background color */
  }

  .profile-header-flex {
    align-items: flex-start; /* align picture + info to left */
  }

  .profile-info-right {
    margin-left: 15px; /* small spacing from profile picture */
    text-align: left;
  }

  .profile-picture-section {
    align-items: flex-start; /* move picture to left */
  }

  .follow-info-horizontal {
    justify-content: flex-start; /* followers left-aligned */
  }
  
}

/* Small screens (keep info to the right of image) */
@media (max-width: 899px) {
  .profile-header-flex {
    flex-direction: row; /* side by side */
    align-items: flex-start; /* top-aligned */
    justify-content: flex-start; /* optional */
    gap: 15px; /* space between image and info */
  }

  .profile-picture-section {
    flex-shrink: 0; /* prevent shrinking */
  }

  .profile-info-right {
    margin-left: 0; /* spacing handled by gap */
    text-align: left;
  }
  
}
@media (max-width: 899px) {
  .profile-picture {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: flex-start; /* force left alignment */
    padding-bottom: 0; /* optional, remove extra space */
  }

  #changePicBtn {
    position: absolute;
    bottom: -10px;  /* adjust vertical position */
    left: 0 !important; /* force left alignment */
    width: 110px; /* reduce width */
    font-size: 0.7rem; /* smaller text */
    padding: 5px 10px; /* adjust padding */
  }
}

@media (max-width: 899px) {
  #editProfileBtn {
    font-size: 0.8rem;      /* smaller text */
    padding: 5px 10px;      /* smaller button */
    width: auto;            /* optional: shrink to content */
  
}
}

@media (max-width: 600px) {
  h2 {
    font-size: 1.2rem;
    text-align: center;
  }
}

@media (max-width: 600px) {
  .nav-logo-img {
    width: 40px;  /* smaller logo image */
  }

  .logo-text {
    font-size: 1rem; /* smaller text */
  }

  .logo {
    margin-left: 10px; /* optional, keep it from touching the edge */
  }
}
/* Shift title and author slightly to the right */
.poem-title,
.poem-author {
  margin-left: 15px; /* adjust as needed */
}

/* Reduce width of comment input and align with card */
.comment-aligned {
  display: flex;
  align-items: center;
  gap: 8px; /* space between inputs and buttons */
  margin-left: 15px; /* same offset as title/author */
}

.comment-aligned .comment-input {
  flex: 1;       /* input takes remaining space */
  max-width: 200px; /* reduced width */
  padding: 6px 10px;
  border-radius: 6px;
  border: 1px solid #ccc;
  font-size: 0.9rem;
}
@media (max-width: 600px) {
  .profile-info-right,
  .profile-info-right p,
  .profile-info-right span,
  .profile-info-right strong {
    color: white !important;
  }

  .profile-buttons .btn {
    color: white !important;
    border-color: white !important;
      background: transparent !important;
  }
}
@media (max-width: 480px) {
  .recent-poem-card {
    margin-bottom: 18px !important;  /* gap between cards */
  }
    }

    /* Container for all badges */
  #badgesContainer {
    display: flex;          /* Horizontal layout */
    flex-wrap: wrap;        /* Wrap to next line if too many */
    justify-content: flex-start; /* Align items to the left */
    gap: 10px;              /* Space between badges */
    margin-top: 10px;
  }

  /* Individual badges */
  #badgesContainer img {
    width: 50px;
    height: 50px;
    border-radius: 0;  /* No circles - square/rectangular */
    object-fit: cover;
    border: none;  /* No border */
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    transition: transform 0.2s;
    cursor: pointer;
  }

  #badgesContainer img:hover {
    transform: scale(1.1);
  }
/* ‚îÄ‚îÄ‚îÄ Volant Classic Initial Avatar ‚îÄ‚îÄ‚îÄ */
.volant-avatar {
  width: 180px;
  height: 180px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;

  font-family: 'Playfair Display', serif;
  font-weight: 700;
  font-size: 3rem;
  letter-spacing: 2px;

  /* Classic ink tone */
  color: #2b1f14;

  /* Paper-like background */
  background:
    radial-gradient(circle at top left, rgba(255,255,255,0.6), rgba(0,0,0,0.03)),
    linear-gradient(135deg, #f6efe7, #e9dfd2);

  /* Elegant frame */
  border: 4px solid #b89b5e; /* antique gold */
  box-shadow:
    inset 0 0 0 6px #fdfaf5,
    0 6px 18px rgba(0,0,0,0.18);

  user-select: none;
  position: relative;
}

/* Inner soft ring */
.volant-avatar::before {
  content: "";
  position: absolute;
  inset: 10px;
  border-radius: 50%;
  border: 1px solid rgba(0,0,0,0.12);
}

/* Initials styling */
/* ‚îÄ‚îÄ‚îÄ Default Generated User Name (Initials Avatar Only) ‚îÄ‚îÄ‚îÄ */
#avatarInitials {
  font-family: 'Libre Baskerville', Georgia, serif;
  font-weight: 700;
  font-size: 3.2rem;     /* controls ONLY the initials size */
  letter-spacing: 3px;
  text-transform: uppercase;
  line-height: 1;
}

.volant-avatar.stamp {
  background: #2f1b12;
  color: #f5e6c8;
  border-color: #7a4b2e;
  box-shadow:
    inset 0 0 20px rgba(0,0,0,0.5),
    0 8px 20px rgba(0,0,0,0.3);
}
/* Regenerate Avatar button styling */
#regenerateAvatarBtn {
  margin-left: 10px;        /* spacing from the previous button */
  padding: 8px 16px;        /* button padding */
  background-color: #4CAF50; /* green background */
  color: #fff;              /* white text */
  border: none;             /* remove default border */
  border-radius: 6px;       /* rounded corners */
  cursor: pointer;          /* pointer on hover */
  font-size: 0.9rem;        /* slightly smaller font */
  transition: background-color 0.3s, transform 0.2s; /* smooth hover effect */
}

/* Hover effect */
#regenerateAvatarBtn:hover {
  background-color: #45a049; /* slightly darker green */
  transform: scale(1.05);    /* slight zoom effect */
}

/* Optional: active/pressed state */
#regenerateAvatarBtn:active {
  transform: scale(0.98);    /* press effect */
}


/* Delete button inside poem card */
.recent-poem-card .delete-btn {
  background-color: #ff4d4d;       /* bright red for delete */
  color: white;
  border: none;
  border-radius: 6px;
  padding: 4px 10px;
  cursor: pointer;
  font-size: 14px;
  margin-left: 8px;
  transition: background-color 0.2s;
}

.recent-poem-card .delete-btn:hover {
  background-color: #e60000;       /* darker red on hover */
}

.recent-poem-card .delete-btn:active {
  transform: scale(0.95);          /* slight click animation */
}


@media screen and (max-width: 600px) {
  .recent-poem-card .delete-btn {
    font-size: 12px;
    padding: 2px 6px;
    margin-left: auto;
  }
}

/* Default: show delete button on all screens at top-right of the card */
.recent-poem-card {
  position: relative; /* make sure absolute positioning works */
}

.recent-poem-card .delete-btn {
  position: absolute;
  top: 8px;
  right: 8px;
  font-size: 14px;
  padding: 4px 8px;
  background: #ff4d4d;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
}

/* Small screens: make it smaller and compact */
@media screen and (max-width: 600px) {
  .recent-poem-card .delete-btn {
    font-size: 12px;
    padding: 2px 6px;
  }

  /* Optional: reduce size of other poem action buttons on small screens */
  .recent-poem-card .poem-actions button,
  .recent-poem-card .poem-actions textarea {
    font-size: 12px;
    padding: 4px 6px;
  }
}

/* Shift date, categories, and read more button to the right */
.poem-date {
  margin-left: 15px !important;
  display: block;
  color: #008080; /* Teal */

}

.poem-category-line {
  margin-left: 15px !important;
}

.read-more-btn {
  margin-left: 15px !important;
}
/* Small screens - reduce font size, move left */
@media (max-width: 768px) {
  .poem-date,
  p.poem-category-line,
  .read-more-btn {
    margin-left: -5px !important;
    font-size: 0.7rem !important;
  }
  
  /* Move categories SLIGHTLY UP */
  p.poem-category-line {
    margin-top: -2px !important;  /* Slightly up, not too much */
    margin-bottom: 6px !important;
  }
  
  .poem-category-line em {
    font-size: 0.7rem !important;
  }
}

/* Even smaller screens */
@media (max-width: 600px) {
  .poem-date,
  p.poem-category-line,
  .read-more-btn {
    margin-left: -8px !important;
    font-size: 0.65rem !important;
  }
  
  /* Move categories SLIGHTLY UP */
  p.poem-category-line {
    margin-top: -3px !important;  /* Slightly more up */
    margin-bottom: 5px !important;
  }
  
  .poem-category-line em {
    font-size: 0.65rem !important;
  }
}

/* Very small screens */
@media (max-width: 480px) {
  .poem-date,
  p.poem-category-line,
  .read-more-btn {
    margin-left: -10px !important;
    font-size: 0.6rem !important;
  }
  
  /* Move categories SLIGHTLY UP */
  p.poem-category-line {
    margin-top: -4px !important;  /* Slightly more up */
    margin-bottom: 4px !important;
  }
  
  .poem-category-line em {
    font-size: 0.6rem !important;
  }
}


/* Fix for small screens - remove left margin from profile layout */
@media (max-width: 899px) {
  .profile-layout {
    margin-left: 0 !important; /* Remove the 40px left margin on mobile */
    width: 100%;
    padding: 0 15px; /* Add small padding instead */
    box-sizing: border-box;
  }
  
  /* Also adjust the stats section */
  .profile-stats-section {
    margin-left: 0 !important;
    margin-right: 0 !important;
    padding: 20px 15px;
    width: 100%;
    box-sizing: border-box;
  }
  
  /* Adjust poems section */
  .profile-poems {
    margin-left: 0 !important;
    margin-right: 0 !important;
    padding: 0 15px;
    width: 100%;
    box-sizing: border-box;
  }
  
  /* Make the Volant Quick panel full width on mobile */
  .interaction-panel {
    width: 100%;
    margin-top: 20px;
  }
}

/* Even smaller screens */
@media (max-width: 600px) {
  .profile-layout {
    padding: 0 10px;
  }
  
  .profile-stats-section {
    padding: 15px 10px;
  }
  
  .profile-poems {
    padding: 0 10px;
  }
}

/* SMALL SCREENS ONLY - Stack everything under profile image */
@media (max-width: 899px) {
  .profile-header-flex {
    flex-direction: column !important;
    align-items: flex-start !important; /* Changed from center to flex-start */
    display: flex !important;
  }
  
  .profile-picture-section {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center; /* Keep picture centered */
    order: 1;
  }
  
  .profile-info-right {
    width: 100%;
    text-align: left !important; /* Changed from center to left */
    margin-left: 0 !important;
    order: 2;
    display: block !important;
    padding-left: 10px; /* Add slight padding from left edge */
  }
  
  .follow-info-horizontal {
    justify-content: center !important;
    margin-top: 20px;
    width: 100%;
    order: 3;
    display: flex !important;
  }
  
  .profile-picture {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
  }
  
  .profile-info-right p {
    text-align: left !important; /* Left align all paragraphs */
    margin: 8px 0;
    color: white !important;
  }
  
  .profile-info-right p strong {
    display: inline-block;
    min-width: 80px;
    color: rgba(255, 255, 255, 0.8);
  }
  
  .profile-info-right p span {
    color: white;
  }
  
  .profile-buttons {
    display: flex;
    justify-content: flex-start !important; /* Changed from center to flex-start */
    margin-top: 15px;
    padding-left: 10px; /* Match the padding of profile-info-right */
  }
  
  #editProfileBtn {
    color: white !important;
    border-color: white !important;
    background: transparent !important;
    margin: 0; /* Remove auto margin */
  }
  
  .follow-item {
    color: white;
  }
  
  .follow-item strong {
    color: white;
    display: block;
    font-size: 1.2rem;
  }
  
  .follow-item span {
    color: rgba(255, 255, 255, 0.8);
    font-size: 0.9rem;
  }
  
  /* Hide the profile container title on small screens */
  .profile-container h2 {
    display: none;
  }
  
  /* Adjust container background */
  .profile-container {
    background-color: #4b2aad !important;
    padding: 20px !important;
  }
}

/* Achievement Modal Styles - matching gallery page exactly */
.preview-modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.9);
  z-index: 2000;
  justify-content: center;
  align-items: center;
  backdrop-filter: blur(4px);
  padding: 16px;
}

.preview-modal.active {
  display: flex;
}

.preview-content {
  max-width: 94%;
  max-height: 90%;
  position: relative;
  animation: fadeUp 0.2s ease;
  display: flex;
  flex-direction: column;
  align-items: center;
}

@keyframes fadeUp {
  0% { opacity: 0.6; transform: translateY(8px); }
  100% { opacity: 1; transform: translateY(0); }
}

.preview-image {
  max-width: 100%;
  max-height: 60vh;
  border-radius: 32px;
  box-shadow: 0 18px 30px rgba(0, 0, 0, 0.5);
  border: 3px solid white;
  background: white;
}

.preview-close {
  position: absolute;
  top: -40px;
  right: -8px;
  width: 42px;
  height: 42px;
  background: white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 22px;
  cursor: pointer;
  border: none;
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
}

.preview-info {
  margin-top: 20px;
  text-align: center;
  color: white;
  text-shadow: 0 1px 4px black;
  padding: 0 6px;
}

.preview-info h3 {
  font-size: 20px;
  margin-bottom: 5px;
  font-weight: 600;
}

.preview-info p {
  font-size: 14px;
  opacity: 0.9;
}

/* --- Image Modal --- */
.image-modal {
  display: none; /* Hidden by default */
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0,0,0,0.85);
  backdrop-filter: blur(3px);
  align-items: center;
  justify-content: center;
}

.image-modal img {
  max-width: 90%;
  max-height: 90%;
  object-fit: contain;
  border-radius: 0 !important; /* Show full shape */
  box-shadow: 0 0 30px rgba(255,255,255,0.2);
  animation: zoomIn 0.3s ease;
  background: transparent !important; /* Force transparent background */
}

/* Ensure the modal background is dark */
.image-modal {
  background-color: rgba(0,0,0,0.85);
}

.close-modal {
  position: absolute;
  top: 20px;
  right: 40px;
  color: white;
  font-size: 40px;
  font-weight: bold;
  cursor: pointer;
  transition: 0.2s;
  z-index: 1001;
}

.close-modal:hover {
  color: #ff6666;
}

@keyframes zoomIn {
  from { transform: scale(0.9); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}

/* Add this to your existing CSS - Achievement badges: 5 in a row on small screens */
@media screen and (max-width: 899px) {
  .badges-container {
    display: grid !important;
    grid-template-columns: repeat(6, 1fr) !important;
    gap: 8px !important;
    justify-content: center !important;
    align-items: center !important;
    width: 100% !important;
  }
  
  .badges-container img {
    width: 100% !important;
    height: auto !important;
    aspect-ratio: 1 / 1 !important;
    max-width: 60px !important;
    margin: 0 auto !important;
  }
}

/* For very small screens, keep 5 in a row but make badges smaller */
@media screen and (max-width: 480px) {
  .badges-container {
    gap: 5px !important;
  }
  
  .badges-container img {
    max-width: 45px !important;
  }
}

/* For extremely small screens, maintain 5 in a row with even smaller badges */
@media screen and (max-width: 360px) {
  .badges-container img {
    max-width: 40px !important;
  }
}
</style>
</head>

<body>
<header>
  <nav>
    <div class="logo">
      <img src="images/logokk.png" alt="Volant Poetry Logo" class="nav-logo-img">
      <span class="logo-text">
        <span class="logo-highlight">Volant</span> Poetry
      </span>
    </div>

    <div class="nav-links" id="nav-links">
      <span class="close-btn" id="close-btn">‚úï</span>
      <a href="index.html">Home</a>
      <a href="about.html">About</a>
       <a href="contact.html">Contact Us</a>
    </div>
<div class="nav-right">

<!-- Mobile Icons -->
    <div class="mobile-icons">
  <!-- Logout Button -->
  <button id="logoutBtnNav" class="btn logout-nav-btn">Logout</button>
  </div>

      <div class="menu-toggle" id="menu-toggle">‚ò∞</div>
    </div>
</nav>
</header>

<!-- PROFILE + QUICK ACCESS WRAPPER -->
<div class="profile-layout">

  <!-- Profile Container (Left Column) -->
  <div class="profile-container">
    <h2>Profile</h2>

    <div class="profile-header-flex">
      <div class="profile-picture-section">
        <div class="profile-picture">
<div id="profileAvatar" class="volant-avatar">
  <span id="avatarInitials"></span>
</div>

<img id="profilePic" style="display:none;" alt="Profile Picture">

          <input type="file" id="uploadPic" style="display:none;">
          <button class="btn" id="changePicBtn">Change Picture</button>
   <button id="regenerateAvatarBtn" style="display:none; margin-left: 10px;">Regenerate Avatar</button> </div>

        <div class="follow-info-horizontal">
          <div class="follow-item">
            <strong id="followersCount">0</strong>
            <span>Followers</span>
          </div>
          <div class="follow-item">
            <strong id="followingCount">0</strong>
            <span>Following</span>
          </div>
        </div>
      </div>

      <div class="profile-info-right">
        <p><strong>Real Name:</strong> <span id="realName"></span></p>
        <p><strong>Username:</strong> <span id="username"></span></p>
        <p><strong>Email:</strong> <span id="email"></span></p>
        <p><strong>Bio:</strong> <span id="bio"></span></p>
        <p><strong>Joined:</strong> <span id="joined"></span></p>
        <div class="profile-buttons">
          <button class="btn" id="editProfileBtn">Edit Profile</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Quick Access (Right Column) -->
  <div class="interaction-panel">
    <h3>Volant Quick</h3>
    <ul>
      
      <li><a href="notifications.html">üîî Notifications</a></li>
      <li><a href="messages.html">‚úâ Messages</a></li>
        <li><a href="submitpoems.html">üìù Submit Poems</a></li>
         <li><a href="user-edit-poems.html">Edit Your Poems</a></li>
             <li><a href="submit-draft.html">Save as Draft</a></li>
                  <li><a href="drafts-manager.html">Manage Draft Poems</a></li>
                   <li><a href="gallery-achievements.html">üèÜ Volant Achievement Gallery üèÜ</a></li>

    </ul>
  </div>

</div>

<!-- HORIZONTAL PROFILE STATS (Full Width Section) -->
<section class="profile-stats-section">
  <div class="interaction-panel-horizontal">

<div class="panel-item">
  <h3>Flight Stage</h3>
  <strong>Flight</strong> <span id="userLevel"></span>
  <div class="level-bar">
    <div id="levelProgress" style="width:0%"></div>
  </div>
  <div id="flightInfo" style="margin-top:8px; font-size:14px; color:#333;"></div>
</div>

    <div class="panel-item">
      <h3>Achievements</h3>
      <div class="badges-container" id="badgesContainer"></div>
    </div>

    <div class="panel-item">
      <h3>Stats</h3>
      <ul>
        <li>Poems Submitted: <span id="poemCount"></span></li>
        <li>Total Likes: <span id="likeCount"></span></li>
        <li>Total Comments: <span id="commentCount"></span></li>
      </ul>
    </div>

    <div class="panel-item">
      <h3>3 Top Poems</h3>
      <div class="top-poem">
        <p id="topPoemContent"></p>
      </div>
    </div>

  </div>
</section>

<!-- Fullscreen image modal -->
<div id="imageModal" class="image-modal">
  <span class="close-modal">&times;</span>
  <img class="modal-content" id="expandedImg">
</div>

<!-- POEMS SECTION -->
<div class="profile-poems">
  <h2>My Submitted Poems</h2>
  <div class="search-bar">
    <input type="text" id="searchInput" placeholder="Search poems..." autocomplete="on">
  </div>
  <div id="poemsContainer">
    <p class="empty-message"></p>
  </div>
</div>

<!-- Achievement Preview Modal - exactly like gallery page -->
<div class="preview-modal" id="previewModal">
  <div class="preview-content">
    <button class="preview-close" id="closePreview">‚úï</button>
    <img class="preview-image" id="previewImage" src="" alt="badge">
    <div class="preview-info" id="previewInfo">
      <h3 id="previewTitle"></h3>
      <p id="previewDescription"></p>
    </div>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { 
  getFirestore, doc, getDoc, setDoc, updateDoc, 
  collection, query, where, getDocs, runTransaction,
  addDoc, deleteDoc  
} from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
import { getStorage } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-storage.js";

const firebaseConfig = {
  apiKey: "AIzaSyC4DHI8aBVY4JjTvJ-r-TGIDPsewtEWxzU",
  authDomain: "silent-depth.firebaseapp.com",
  projectId: "silent-depth",
  storageBucket: "silent-depth.appspot.com",
  messagingSenderId: "78008755450",
  appId: "1:78008755450:web:3fd0f0f298a08820935543"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);
const storage = getStorage(app);

// --- Get ?uid from URL ---
const urlParams = new URLSearchParams(window.location.search);
const profileUid = urlParams.get("uid");

// --- DOM elements ---
const realNameSpan = document.getElementById("realName");
const usernameSpan = document.getElementById("username");
const emailSpan = document.getElementById("email");
const bioSpan = document.getElementById("bio");
const joinedSpan = document.getElementById("joined");
const profilePic = document.getElementById("profilePic");
const editBtn = document.getElementById("editProfileBtn");
const changePicBtn = document.getElementById("changePicBtn");
const uploadPic = document.getElementById("uploadPic");
const poemsContainer = document.getElementById("poemsContainer");

let actorUsername = "";
let profileUsername = "";
let viewingOwnProfile = false;

// --- Modal functions - exactly like gallery page ---
window.showPreview = function(imageUrl, title, description) {
  document.getElementById('previewImage').src = imageUrl;
  document.getElementById('previewTitle').textContent = title;
  document.getElementById('previewDescription').textContent = description;
  document.getElementById('previewModal').classList.add('active');
  document.body.style.overflow = 'hidden';
};

function hidePreview() {
  document.getElementById('previewModal').classList.remove('active');
  document.body.style.overflow = 'auto';
}

// Modal event listeners
document.getElementById('closePreview').addEventListener('click', hidePreview);
document.getElementById('previewModal').addEventListener('click', (e) => {
  if (e.target === document.getElementById('previewModal')) hidePreview();
});
document.addEventListener('keydown', (e) => { if (e.key === 'Escape') hidePreview(); });

// --- Truncate poems by number of lines ---
function truncatePoemByLines(text, maxLines = 8) {
  const lines = text.split(/\r?\n/);
  const truncated = lines.slice(0, maxLines).join("\n");
  return {
    preview: truncated,
    full: text,
    truncated: lines.length > maxLines
  };
}

// --- Fetch total comments made by the user across all poems ---
async function fetchTotalCommentsMade(username) {
  try {
    if (!username) return 0;
    
    let totalComments = 0;
    const poemsRef = collection(db, "recentPoems");
    const snapshot = await getDocs(poemsRef);
    
    for (const poemDoc of snapshot.docs) {
      const commentsRef = collection(db, "recentPoems", poemDoc.id, "comments");
      const commentsSnap = await getDocs(commentsRef);
      
      commentsSnap.forEach(commentDoc => {
        const commentData = commentDoc.data();
        if (commentData.user === username || commentData.userId === auth.currentUser?.uid) {
          totalComments++;
        }
      });
    }
    
    return totalComments;
  } catch (err) {
    console.error("Error fetching total comments made:", err);
    return 0;
  }
}

// --- Show default comment badges if no achievements configured ---
function showDefaultCommentBadges(container, totalCommentsMade) {
  container.innerHTML = "";
  
  const commentBadges = [
    { min: 1, title: "First Comment", icon: "üí¨", color: "#4CAF50", description: "You made your first comment on a poem!" },
    { min: 10, title: "Active Commenter", icon: "üó£Ô∏è", color: "#2196F3", description: "You've made 10 comments on poems." },
    { min: 50, title: "Conversation Starter", icon: "‚≠ê", color: "#9C27B0", description: "50 comments! You're starting great conversations." },
    { min: 100, title: "Comment Master", icon: "üëë", color: "#FF9800", description: "100 comments! You're a true poetry community member." }
  ];
  
  let earnedAny = false;
  
  commentBadges.forEach(badge => {
    if (totalCommentsMade >= badge.min) {
      earnedAny = true;
      
      const img = document.createElement("img");
      // Create a colored square with emoji as fallback
      img.src = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='50' height='50'%3E%3Crect width='50' height='50' fill='${badge.color.replace('#', '%23')}'/%3E%3Ctext x='25' y='35' font-size='24' text-anchor='middle' fill='white'%3E${badge.icon}%3C/text%3E%3C/svg%3E`;
      img.alt = badge.title;
      img.title = `${badge.title} (${badge.min}+ comments)`;
      
      img.addEventListener("click", () => {
        showPreview(
          img.src,
          badge.title,
          badge.description
        );
      });
      
      container.appendChild(img);
    }
  });
  
  if (!earnedAny) {
    container.innerHTML = '<p style="color: #888; font-size: 0.9rem; margin: 0;">Make your first comment to earn badges!</p>';
  }
}

// --- Update Achievements dynamically with click handlers ---
async function updateAchievements(poemCount, totalLikes, totalCommentsReceived, totalCommentsMade) {
  const badgesContainer = document.querySelector(".badges-container");
  if (!badgesContainer) return;
  badgesContainer.innerHTML = "";

  try {
    const snapshot = await getDocs(collection(db, "achievements"));
    
    if (!snapshot.empty) {
      const achievements = snapshot.docs.map(docSnap => ({ id: docSnap.id, ...docSnap.data() }));

      const earned = achievements.filter(a => {
        if (!a.active) return false;
        const { type, min } = a.condition || {};
        switch(type) {
          case "poemsSubmitted": return poemCount >= min;
          case "likesReceived": return totalLikes >= min;
          case "commentsMade": return totalCommentsMade >= min;
          case "commentsReceived": return totalCommentsReceived >= min;
          default: return false;
        }
      });

      if (earned.length > 0) {
        earned.forEach(badge => {
          const img = document.createElement("img");
          img.src = badge.imageUrl || `https://via.placeholder.com/50/5a67d8/ffffff?text=${badge.title?.charAt(0) || 'üèÜ'}`;
          img.alt = badge.title || "Achievement Badge";
          img.title = badge.title || "Achievement";
          
          img.addEventListener("click", () => {
            showPreview(
              badge.imageUrl || `https://via.placeholder.com/200/5a67d8/ffffff?text=${encodeURIComponent(badge.title?.charAt(0) || 'üèÜ')}`,
              badge.title || "Achievement",
              badge.description || "You earned this achievement!"
            );
          });
          
          badgesContainer.appendChild(img);
        });
      } else {
        badgesContainer.innerHTML = '<p style="color: #888; font-size: 0.9rem; margin: 0;">No badges yet</p>';
      }
    } else {
      showDefaultCommentBadges(badgesContainer, totalCommentsMade);
    }
  } catch (err) {
    console.error("Error loading dynamic achievements:", err);
    showDefaultCommentBadges(badgesContainer, totalCommentsMade);
  }

  updateLevel(poemCount, totalLikes, totalCommentsReceived, totalCommentsMade);
}

// --- Update Level function ---
function updateLevel(poemCount, totalLikes, totalCommentsReceived, totalCommentsMade) {
  const levelEl = document.getElementById("userLevel");
  const levelProgressEl = document.getElementById("levelProgress");

  let levelInfoEl = document.querySelector(".panel-item .level-info");
  if (!levelInfoEl) {
    levelInfoEl = document.createElement("div");
    levelInfoEl.className = "level-info";
    levelInfoEl.style.marginTop = "8px";
    levelInfoEl.style.fontSize = "14px";
    levelInfoEl.style.color = "#333";
    const panelItem = document.querySelector(".panel-item");
    if (panelItem) panelItem.appendChild(levelInfoEl);
  }

  let baseRequirements = {
    poems: 2,
    likes: 2,
    commentsMade: 2,
    commentsReceived: 1
  };

  let level = 1;
  let poems = poemCount;
  let likes = totalLikes;
  let commentsMade = totalCommentsMade;
  let commentsReceived = totalCommentsReceived;
  let remaining = { poems: 0, likes: 0, commentsMade: 0, commentsReceived: 0 };

  while (true) {
    const poemProgress = poems / baseRequirements.poems;
    const likesProgress = likes / baseRequirements.likes;
    const commentsMadeProgress = commentsMade / baseRequirements.commentsMade;
    const commentsReceivedProgress = commentsReceived / baseRequirements.commentsReceived;

    const levelProgress = Math.min((poemProgress + likesProgress + commentsMadeProgress + commentsReceivedProgress) / 4, 1);

    if (levelProgress >= 1) {
      level++;
      poems -= baseRequirements.poems;
      likes -= baseRequirements.likes;
      commentsMade -= baseRequirements.commentsMade;
      commentsReceived -= baseRequirements.commentsReceived;

      baseRequirements.poems = Math.ceil(baseRequirements.poems * 1.5);
      baseRequirements.likes = Math.ceil(baseRequirements.likes * 1.5);
      baseRequirements.commentsMade = Math.ceil(baseRequirements.commentsMade * 1.5);
      baseRequirements.commentsReceived = Math.ceil(baseRequirements.commentsReceived * 1.5);
    } else {
      remaining.poems = Math.max(baseRequirements.poems - poems, 0);
      remaining.likes = Math.max(baseRequirements.likes - likes, 0);
      remaining.commentsMade = Math.max(baseRequirements.commentsMade - commentsMade, 0);
      remaining.commentsReceived = Math.max(baseRequirements.commentsReceived - commentsReceived, 0);

      if (levelProgressEl) levelProgressEl.style.width = `${levelProgress * 100}%`;
      break;
    }
  }

  if (levelEl) levelEl.textContent = level;

  if (levelInfoEl) {
    levelInfoEl.innerHTML = `
      <strong>Remaining to next flight:</strong><br>
      Poems: ${remaining.poems}<br>
      Likes: ${remaining.likes}<br>
      Comments Made: ${remaining.commentsMade}<br>
      Comments Received: ${remaining.commentsReceived}
    `;
  }
}

function getInitials(name = "") {
  const parts = name.trim().split(" ");
  if (parts.length === 1) return parts[0][0]?.toUpperCase() || "?";
  return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
}

function colorFromName(name = "") {
  let hash = 0;
  for (let i = 0; i < name.length; i++) {
    hash = name.charCodeAt(i) + ((hash << 5) - hash);
  }
  const hue = Math.abs(hash) % 360;
  return `hsl(${hue}, 60%, 45%)`;
}

// --- Generate a PNG blob of initials with background color ---
// --- Generate a PNG blob of initials with background color - SAVE AS SQUARE ---
function generateAvatarImage(initials, bgColor, size = 180) {
  const canvas = document.createElement("canvas");
  canvas.width = canvas.height = size;
  const ctx = canvas.getContext("2d");

  // Fill with background color - full square, no circle clipping
  ctx.fillStyle = bgColor;
  ctx.fillRect(0, 0, size, size);

  // Add text
  ctx.fillStyle = "#ffffff";
  ctx.font = `${size * 0.5}px 'Playfair Display', serif`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(initials, size / 2, size / 2);

  // Add a subtle border to match styling
  ctx.strokeStyle = "#b89b5e";
  ctx.lineWidth = 4;
  ctx.strokeRect(2, 2, size - 4, size - 4);

  return new Promise(resolve => {
    canvas.toBlob(blob => resolve(blob), "image/png");
  });
}

// --- Upload generated initials image to Cloudinary & update Firestore ---
async function uploadAvatarToCloudinary(initials, bgColor, publicId = null) {
  const blob = await generateAvatarImage(initials, bgColor);

  const formData = new FormData();
  formData.append("file", blob);
  formData.append("upload_preset", "profile_pics");
  if (publicId) formData.append("public_id", publicId);

  const cloudName = "dzoq4pgjn";

  try {
    const res = await fetch(`https://api.cloudinary.com/v1_1/${cloudName}/image/upload`, {
      method: "POST",
      body: formData
    });
    const data = await res.json();
    
    // Get the URL without any circle transformations
    const imageUrl = data.secure_url;
    
    // Remove any auto-cropping/circle transformations if present
    const cleanUrl = imageUrl.replace(/\/upload\/.*?\//, '/upload/');

    const user = auth.currentUser;
    if (user) {
      const userRef = doc(db, "users", user.uid);
      await updateDoc(userRef, { 
        photoURL: cleanUrl,          
        cachedAvatarURL: cleanUrl    
      });
    }

    return cleanUrl;
  } catch (err) {
    console.error("Cloudinary upload failed:", err);
    return null;
  }
}
 
// --- Auth handling ---
onAuthStateChanged(auth, async (user) => {
  if (!user) {
    window.location.href = "users-login.html";
    return;
  }

  const actorRef = doc(db, "users", user.uid);
  let actorDoc = await getDoc(actorRef);
  if (!actorDoc.exists()) {
    await setDoc(actorRef, {
      username: user.displayName || user.email.split("@")[0],
      email: user.email,
      bio: "",
      realName: "",
      joined: new Date(),
      photoURL: user.photoURL || ""
    });
    actorDoc = await getDoc(actorRef);
  }
  const actorData = actorDoc.data();
  actorUsername = actorData.username || user.email.split("@")[0];

  viewingOwnProfile = !profileUid || profileUid === user.uid;
  const targetUid = viewingOwnProfile ? user.uid : profileUid;

  const userRef = doc(db, "users", targetUid);
  const userDoc = await getDoc(userRef);

  if (!userDoc.exists()) {
    alert("User not found.");
    window.location.href = "index.html";
    return;
  }

  const data = userDoc.data();
  profileUsername = data.username || data.email.split("@")[0];

  if (realNameSpan) realNameSpan.textContent = data.realName || "Not set";
  if (usernameSpan) usernameSpan.textContent = profileUsername;
  if (emailSpan) emailSpan.textContent = data.email || "";
  if (bioSpan) bioSpan.textContent = data.bio || "No bio yet";
  if (joinedSpan) {
    joinedSpan.textContent = data.joined
      ? (data.joined.seconds
          ? new Date(data.joined.seconds * 1000).toDateString()
          : new Date(data.joined).toDateString())
      : "Unknown";
  }
  
  const avatarDiv = document.getElementById("profileAvatar");
  const avatarText = document.getElementById("avatarInitials");

  // In the onAuthStateChanged function, update the avatar display section:

if (data.photoURL) {
  // If there's a photo URL, use it
  profilePic.src = data.photoURL;
  profilePic.style.display = "block";
  profilePic.style.borderRadius = "50%"; // Make it circular for display
  avatarDiv.style.display = "none";
} else if (data.cachedAvatarURL) {
  profilePic.src = data.cachedAvatarURL;
  profilePic.style.display = "block";
  profilePic.style.borderRadius = "50%"; // Make it circular for display
  avatarDiv.style.display = "none";
} else {
  // Show the generated avatar
  const initials = getInitials(profileUsername);
  const bgColor = colorFromName(profileUsername);

  avatarText.textContent = initials;
  avatarDiv.style.background = bgColor;
  avatarDiv.style.display = "flex";
  profilePic.style.display = "none";
  
  // Upload as square image
  if (viewingOwnProfile) {
    uploadAvatarToCloudinary(initials, bgColor).then(url => {
      if (url) {
        profilePic.src = url;
        profilePic.style.display = "block";
        profilePic.style.borderRadius = "50%"; // Make it circular for display
        avatarDiv.style.display = "none";
      }
    });
  }
}
  
  const regenerateAvatarBtn = document.getElementById("regenerateAvatarBtn");

if (regenerateAvatarBtn && viewingOwnProfile) {
  regenerateAvatarBtn.style.display = "inline-block";
  regenerateAvatarBtn.addEventListener("click", async () => {
    const initials = getInitials(profileUsername);
    const bgColor = colorFromName(profileUsername);

    try {
      let publicId = null;
      if (profilePic.src) {
        const urlParts = profilePic.src.split("/");
        const filename = urlParts[urlParts.length - 1].split(".")[0];
        publicId = `profile_pics/${filename}`;
      }

      const newAvatarUrl = await uploadAvatarToCloudinary(initials, bgColor, publicId);
      if (newAvatarUrl) {
        profilePic.src = newAvatarUrl;
        profilePic.style.display = "block";
        profilePic.style.borderRadius = "50%"; // Make it circular for display
        document.getElementById("profileAvatar").style.display = "none";
        alert("‚úÖ Avatar regenerated and replaced successfully!");
      } else {
        alert("‚ùå Failed to regenerate avatar.");
      }
    } catch (err) {
      console.error("Error regenerating avatar:", err);
      alert("‚ùå Something went wrong.");
    }
  });
}

  if (!viewingOwnProfile) {
    if (editBtn) editBtn.style.display = "none";
    if (changePicBtn) changePicBtn.style.display = "none";
    if (uploadPic) uploadPic.style.display = "none";
  }
  if (viewingOwnProfile && editBtn) {
    editBtn.style.display = "inline-block";
    editBtn.addEventListener("click", () => {
      window.location.href = "edit-profile.html";
    });
  }

  if (!viewingOwnProfile) {
    const quickAccessPanel = document.querySelector(".interaction-panel");
    if (quickAccessPanel) {
      quickAccessPanel.style.display = "none";
    }
  }

  await fetchUserPoems(profileUsername);
  await fetchTopPoems(profileUsername);
});

// --- Fetch User Poems ---
async function fetchUserPoems(usernameToFetch) {
  try {
    const q = query(
      collection(db, "recentPoems"), 
      where("submittedBy", "==", usernameToFetch)
    );
    
    const querySnap = await getDocs(q);
    const container = poemsContainer;
    container.innerHTML = "";

    let totalLikes = 0;
    let totalCommentsReceived = 0;
    let poemCount = querySnap.size;
    let totalCommentsMade = 0;

    if (viewingOwnProfile) {
      totalCommentsMade = await fetchTotalCommentsMade(actorUsername);
    }

    if (querySnap.empty) {
      container.innerHTML = `<p class="empty-message">No poems yet.</p>`;
    } else {
      const poemsArray = [];
      
      for (const docSnap of querySnap.docs) {
        const poem = docSnap.data();
        poem.id = docSnap.id;
        poemsArray.push(poem);
      }
      
      poemsArray.sort((a, b) => {
        const timeA = a.timestamp?.seconds || 0;
        const timeB = b.timestamp?.seconds || 0;
        return timeB - timeA;
      });
      
      for (const poem of poemsArray) {
        const docId = poem.id;
        const card = document.createElement("div");
        card.className = "recent-poem-card";
        card.dataset.id = docId;

        const truncated = truncatePoemByLines(poem.content, 8);
        const likes = typeof poem.likes === "number" ? poem.likes : 0;
        totalLikes += likes;

        let commentsSnapCount = 0;
        try {
          const commentsSnap = await getDocs(collection(db, "recentPoems", docId, "comments"));
          commentsSnapCount = commentsSnap.size;
        } catch (err) {
          commentsSnapCount = Array.isArray(poem.comments) ? poem.comments.length : 0;
        }
        totalCommentsReceived += commentsSnapCount;

        const dateStr = poem.timestamp 
          ? new Date(poem.timestamp.seconds * 1000).toLocaleDateString() + ' ' + new Date(poem.timestamp.seconds * 1000).toLocaleTimeString()
          : "";

        card.innerHTML = `
          <div class="poem-display">
            <h3 class="poem-title">${poem.title}</h3>
            ${dateStr ? `<small class="poem-date">${dateStr}</small>` : ""}
            <button class="delete-btn">üóëÔ∏è Delete</button>
            <div class="poem-body">
              <p class="poem-content">${truncated.preview.replace(/\n/g, "<br>")}</p>
              ${truncated.truncated ? `<button class="read-more-btn">Show More</button>` : ""}
            </div>
          </div>
          ${poem.categories && poem.categories.length > 0 ? `<p class="poem-category-line"><em>${poem.categories.join(", ")}</em></p>` : ""}
          <div class="poem-actions comment-aligned">
            <textarea class="comment-input" placeholder="Write a comment..." rows="1"></textarea>
            <button class="comment-btn">Post</button>
            <button class="like-btn">
              ‚ù§Ô∏è <span class="like-count">${likes}</span>
            </button>
            <span class="message-count">üí¨ ${commentsSnapCount}</span>
          </div>
          <div class="comment-list" style="display:none;"></div>
        `;

        const deleteBtn = card.querySelector(".delete-btn");
        if (viewingOwnProfile) {
          deleteBtn.style.display = "inline-block";
        } else {
          deleteBtn.style.display = "none";
        }

        container.appendChild(card);
      }
    }

    const poemCountEl = document.getElementById("poemCount");
    const likeCountEl = document.getElementById("likeCount");
    const commentCountEl = document.getElementById("commentCount");
    if (poemCountEl) poemCountEl.textContent = poemCount;
    if (likeCountEl) likeCountEl.textContent = totalLikes;
    if (commentCountEl) commentCountEl.textContent = totalCommentsReceived;

    updateAchievements(poemCount, totalLikes, totalCommentsReceived, totalCommentsMade);
    updateLevel(poemCount, totalLikes, totalCommentsReceived, totalCommentsMade);
  } catch (err) {
    console.error("Error fetching poems:", err);
    poemsContainer.innerHTML = `<p class='empty-message'>Error loading poems: ${err.message}</p>`;
  }
}

// --- Fetch Top 3 Poems ---
async function fetchTopPoems(profileName) {
  try {
    if (!profileName) return;

    const poemsRef = collection(db, "recentPoems");
    const q = query(poemsRef, where("submittedBy", "==", profileName));
    const snapshot = await getDocs(q);

    const topPoemContent = document.getElementById("topPoemContent");
    if (!topPoemContent) return;

    if (snapshot.empty) {
      topPoemContent.textContent = "No poems yet.";
      return;
    }

    const poems = [];

    snapshot.forEach((docSnap) => {
      const poem = docSnap.data();
      if (!poem.title) return;

      const likes = poem.likes || 0;
      const comments = Array.isArray(poem.comments) ? poem.comments.length : 0;
      const engagement = likes + comments;

      const slug = poem.slug || poem.title.toLowerCase().replace(/\s+/g, "-").replace(/[^\w-]+/g, "");
      poems.push({ slug, title: poem.title, engagement });
    });

    const top3 = poems.sort((a, b) => b.engagement - a.engagement).slice(0, 3);

    topPoemContent.innerHTML = top3.length
      ? top3
          .map(
            (p, i) =>
              `<div style="margin-bottom:4px;">
                <span style="display:inline;">${i + 1}.</span>
                <a href="poem.html?slug=${encodeURIComponent(p.slug)}" class="top-poem-link" style="display:inline;">${p.title}</a>
              </div>`
          )
          .join("")
      : "No top poems yet.";
  } catch (error) {
    console.error("Error fetching top poems:", error);
  }
}

// --- Cloudinary Upload ---
if (changePicBtn) {
  const cloudName = "dzoq4pgjn";
  const uploadPreset = "profile_pics";

  changePicBtn.addEventListener("click", () => {
    if (!viewingOwnProfile) return alert("You cannot change another user's picture.");
    uploadPic.click();
  });

  uploadPic.addEventListener("change", async (e) => {
    if (!viewingOwnProfile) return;
    const file = e.target.files[0];
    if (!file) return;

    const formData = new FormData();
    formData.append("file", file);
    formData.append("upload_preset", uploadPreset);

    try {
      const res = await fetch(`https://api.cloudinary.com/v1_1/${cloudName}/image/upload`, {
        method: "POST",
        body: formData
      });
      const data = await res.json();
      
      // Get the raw URL without any transformations
      const imageUrl = data.secure_url;

      if (profilePic) {
        profilePic.src = imageUrl;
        profilePic.style.borderRadius = "50%"; // Make it circular for display
      }

      const user = auth.currentUser;
      if (user) {
        await updateDoc(doc(db, "users", user.uid), { photoURL: imageUrl });
      }

      console.log("‚úÖ Uploaded to Cloudinary:", imageUrl);
    } catch (err) {
      console.error("‚ùå Cloudinary upload error:", err);
    }
  });
}

// --- Profile picture expand on click ---
// --- Profile picture expand on click ---
const modal = document.getElementById("imageModal");
const expandedImg = document.getElementById("expandedImg");
const closeModal = document.querySelector(".close-modal");
const profilePicEl = document.getElementById("profilePic");
const profileAvatar = document.getElementById("profileAvatar");

// Function to show modal with image
function showImageModal(imageSrc) {
  if (expandedImg) {
    expandedImg.src = imageSrc;
    // Remove any border-radius that might be applied
    expandedImg.style.borderRadius = "0";
    expandedImg.style.maxWidth = "90%";
    expandedImg.style.maxHeight = "90%";
    expandedImg.style.objectFit = "contain";
    expandedImg.style.background = "transparent"; // Ensure no background
  }
  if (modal) modal.style.display = "flex";
}

// Handle click on uploaded profile picture
if (profilePicEl) {
  profilePicEl.addEventListener("click", () => {
    if (profilePicEl.src) {
      showImageModal(profilePicEl.src);
    }
  });
}

// Handle click on generated avatar
if (profileAvatar) {
  profileAvatar.addEventListener("click", () => {
    // If there's an uploaded image, use that instead
    if (profilePicEl && profilePicEl.style.display !== "none" && profilePicEl.src) {
      showImageModal(profilePicEl.src);
    } else {
      // For generated avatar, create an image that preserves the circular styling
      const initials = document.getElementById("avatarInitials")?.textContent || "?";
      const bgColor = window.getComputedStyle(profileAvatar).backgroundColor;
      
      // Get the computed styles to match exactly
      const avatarStyles = window.getComputedStyle(profileAvatar);
      const borderColor = avatarStyles.borderColor;
      const borderWidth = avatarStyles.borderWidth;
      const boxShadow = avatarStyles.boxShadow;
      
      // Create a canvas to generate the avatar image
      const canvas = document.createElement("canvas");
      canvas.width = 500; // Higher resolution
      canvas.height = 500;
      const ctx = canvas.getContext("2d");
      
      // Clear canvas with transparency
      ctx.clearRect(0, 0, 500, 500);
      
      // Draw the circular background
      ctx.beginPath();
      ctx.arc(250, 250, 240, 0, 2 * Math.PI); // Slightly smaller to account for border
      ctx.fillStyle = bgColor;
      ctx.fill();
      
      // Draw the inner shadow/ring effect (from the ::before pseudo-element)
      ctx.beginPath();
      ctx.arc(250, 250, 230, 0, 2 * Math.PI);
      ctx.strokeStyle = "rgba(0,0,0,0.12)";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw the border
      ctx.beginPath();
      ctx.arc(250, 250, 240, 0, 2 * Math.PI);
      ctx.strokeStyle = borderColor || "#b89b5e";
      ctx.lineWidth = parseInt(borderWidth) || 4;
      ctx.stroke();
      
      // Draw the initials
      ctx.fillStyle = "#ffffff";
      ctx.font = "bold 200px 'Playfair Display', serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(initials, 250, 250);
      
      // Add a subtle radial gradient for depth (matching the original)
      const gradient = ctx.createRadialGradient(150, 150, 50, 250, 250, 300);
      gradient.addColorStop(0, "rgba(255,255,255,0.2)");
      gradient.addColorStop(1, "rgba(0,0,0,0.1)");
      ctx.fillStyle = gradient;
      ctx.globalCompositeOperation = "overlay";
      ctx.beginPath();
      ctx.arc(250, 250, 250, 0, 2 * Math.PI);
      ctx.fill();
      
      // Convert to data URL and show in modal
      const dataUrl = canvas.toDataURL("image/png");
      showImageModal(dataUrl);
    }
  });
}

// Close modal handlers
if (closeModal) {
  closeModal.addEventListener("click", () => {
    if (modal) modal.style.display = "none";
  });
}

window.addEventListener("click", (e) => {
  if (e.target === modal) modal.style.display = "none";
});

// Also make the avatar have pointer cursor to indicate it's clickable
if (profileAvatar) {
  profileAvatar.style.cursor = "pointer";
}
// Menu toggle and nav
const menuToggle = document.getElementById("menu-toggle");
const navLinks = document.getElementById("nav-links");
const closeBtn = document.getElementById("close-btn");

if (menuToggle) {
  menuToggle.addEventListener("click", () => {
    navLinks.classList.toggle("show");
  });
}
if (closeBtn) {
  closeBtn.addEventListener("click", () => {
    navLinks.classList.remove("show");
  });
}

// --- Logout Nav Button ---
const logoutBtnNav = document.getElementById("logoutBtnNav");
if (logoutBtnNav) {
  logoutBtnNav.addEventListener("click", async () => {
    if (!auth.currentUser) {
      alert("No user is logged in.");
      return;
    }
    try {
      await signOut(auth);
      window.location.href = "users-login.html";
    } catch (err) {
      console.error("Logout failed:", err);
      alert("Logout failed, try again.");
    }
  });
}

// --- Search Filter ---
const searchInput = document.getElementById("searchInput");
let debounceTimeout;

const loadedPoemIds = new Set(
  Array.from(document.querySelectorAll(".recent-poem-card")).map(
    card => card.dataset.id
  )
);

if (searchInput) {
  searchInput.addEventListener("input", () => {
    clearTimeout(debounceTimeout);
    debounceTimeout = setTimeout(async () => {
      const filter = searchInput.value.trim().toLowerCase();
      filterDOM(filter);
      await searchFirestore(filter);
    }, 300);
  });
}

function filterDOM(filter) {
  const cards = document.querySelectorAll(".recent-poem-card");
  let anyVisible = false;

  cards.forEach(card => {
    const title = card.querySelector(".poem-title")?.textContent.toLowerCase() || "";
    const content = card.querySelector(".poem-content")?.textContent.toLowerCase() || "";
    const categories = (card.dataset.categories || "").toLowerCase();

    if (title.includes(filter) || content.includes(filter) || categories.includes(filter)) {
      card.style.display = "block";
      anyVisible = true;
    } else {
      card.style.display = "none";
    }
  });

  showEmptyMessage(!anyVisible);
}

async function searchFirestore(filter) {
  if (!filter) return;

  const poemsRef = collection(db, "recentPoems");
  const snapshot = await getDocs(poemsRef);

  let anyNewResults = false;

  snapshot.docs.forEach(docSnap => {
    const data = docSnap.data();
    const id = docSnap.id;

    if (loadedPoemIds.has(id)) return;

    const title = (data.title || "").toLowerCase();
    const content = (data.content || "").toLowerCase();
    const categories = (data.categories || "").toLowerCase();

    if (title.includes(filter) || content.includes(filter) || categories.includes(filter)) {
      addPoemCardToDOM(id, data);
      loadedPoemIds.add(id);
      anyNewResults = true;
    }
  });

  const anyVisible = document.querySelectorAll(".recent-poem-card:not([style*='display: none'])").length > 0;
  showEmptyMessage(!anyVisible);
}

function addPoemCardToDOM(id, data) {
  const container = document.getElementById("poemsContainer");
  if (!container) return;
  const card = document.createElement("div");
  card.className = "recent-poem-card";
  card.dataset.id = id;
  card.dataset.categories = data.categories || "";

  card.innerHTML = `
    <h3 class="poem-title">${data.title || ""}</h3>
    <p class="poem-content">${data.content || ""}</p>
  `;

  container.appendChild(card);
}

function showEmptyMessage(show) {
  const container = document.getElementById("poemsContainer");
  if (!container) return;
  let msg = container.querySelector(".empty-message");
  if (show) {
    if (!msg) {
      msg = document.createElement("p");
      msg.className = "empty-message";
      container.appendChild(msg);
    }
    msg.textContent = "No poems match your search.";
  } else if (msg) {
    msg.textContent = "";
  }
}
</script>

</body>
</html>