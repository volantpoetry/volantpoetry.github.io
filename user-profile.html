<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>My Profile & Poems | Silent Depth</title>

<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@500;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  
<link rel="stylesheet" href="style.css" />
<link rel="icon" type="image/png" href="images/logo.png" />
<link rel="apple-touch-icon" href="images/logo.png" />

<style>
:root {
  --primary: #4b2aad;
  --bg: #f7f5ff;
  --text: #1a1a1a;
  --muted: #666;
  --radius: 14px;
}

body {
  font-family: 'Inter', sans-serif;
  background: var(--bg);
  color: var(--text);
  margin: 0;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
}

header {
  width: 100%;
}

/* Profile Section */
.profile-container {
  background: #fff;
  padding: 2rem;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  width: 90%;
  max-width: 500px;
  text-align: center;
  margin-top: 40px;
}

.profile-container h2 { color: var(--primary); margin-bottom: 1rem; }

.profile-picture img {
  width: 100px;
  height: 100px;
  border-radius: 50%;
  object-fit: cover;
  margin-bottom: 0.8rem;
  border: 3px solid var(--primary);
}

.profile-info { margin: 1rem 0; font-size: 1rem; color: #333; }
.profile-info p { margin: 0.5rem 0; }

.btn {
  padding: 0.5rem 1rem;
  background: var(--primary);
  color: #fff;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: 0.2s;
  margin-top: 0.5rem;
}

.btn:hover { background: #6c3ddd; }

#editProfileBtn { background: #fff; color: var(--primary); border: 1px solid var(--primary); }
#editProfileBtn:hover { background: var(--primary); color: #fff; }

/* Poems Section */
.profile-poems {
  width: 100%;
  max-width: 900px;
  margin: 40px auto;
  transform: translateX(40px);
}

h2 {
  text-align: center;
  font-family: 'Playfair Display', serif;
  font-weight: 600;
  margin: 20px auto 30px auto;
  color: #4b2aad;
}

.profile-poems h3 {
  color: var(--primary);
  text-align: left;
  font-family: 'Playfair Display', serif;
  margin-bottom: 1.5rem;
}

.recent-poem-card {
  background: linear-gradient(160deg, #fdf6f0, #e2e9f0);
  color: #4b3f2f;
  border-radius: 12px;
  padding: 1.2rem;
  margin-bottom: 2rem;
}
/* Center on small screens */
@media (max-width: 768px) {
  .recent-poem-card {
    margin-left: -5;
    margin-right: auto;
    width: 100%; /* optional: make it responsive */
  }
}
.poem-content {
  white-space: pre-wrap;
  line-height: 1.7;
  overflow: hidden;
    padding-left: 12px; /* moves text slightly to the right */
}

/* --- Force smaller comment box --- */
.recent-poem-card .comment-section {
  display: flex;
  align-items: center;
  justify-content: flex-start;
  gap: 8px;
}

.recent-poem-card .comment-input {
  flex: none !important;        /* stop auto-stretching */
  width: 220px !important;      /* fixed smaller width */
  max-width: 65% !important;    /* optional safety */

}
/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Desktop Layout (Two-Column) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
@media (min-width: 900px) {
  .profile-layout {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 40px;
    width: 90%;
    max-width: 1100px;
    margin-top: 50px;
  }

  .profile-container {
    max-width: 100%;
    margin: 0;
    text-align: left;
  }

  .profile-container h2 {
    text-align: left;
  }

  .interaction-panel {
    background: #fff;
    border-radius: 12px;
    box-shadow: 0 3px 10px rgba(0,0,0,0.08);
    padding: 1.5rem;
    height: fit-content;
  }

  .interaction-panel h3 {
    font-family: 'Playfair Display', serif;
    color: var(--primary);
    font-weight: 600;
    margin-bottom: 1rem;
  }

  .interaction-panel ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .interaction-panel li {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 0;
    border-bottom: 1px solid #eee;
    cursor: pointer;
    transition: 0.2s;
  }

  .interaction-panel li:hover {
    color: var(--primary);
    background: #f7f5ff;
    border-radius: 8px;
    padding-left: 10px;
  }
}

/* Poem section stays full width below both columns */
.profile-poems {
  grid-column: 1 / span 2;
  width: 90%;
  max-width: 1100px;
  margin-top: 50px;
  transform: none;
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Search Bar Styling ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Search Bar Styling ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.search-bar {
  display: flex;
  align-items: center;
  justify-content: flex-end; /* Move to right */
  gap: 10px;
  margin: 20px auto 30px;
  width: 100%;              /* Full width container */
  max-width: 900px;         /* Keeps it aligned with your cards */
  padding-right: 50px;      /* Push in from right edge */
}

.search-bar input {
  flex: 0 1 250px;          /* Fixed input width but still responsive */
  padding: 10px 14px;
  font-size: 15px;
  border: 1px solid #ddd;
  border-radius: var(--radius);
  outline: none;
  transition: 0.2s;
  background: #fff;
}

.search-bar input:focus {
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(75, 42, 173, 0.1);
}
.search-bar {
  display: flex;
  justify-content: flex-end;
  align-items: center;
  margin: 10px 0 20px;
  width: 100%;
  padding-right: 15px; /* tighter spacing */
}

.search-bar input {
  width: 150px;               /* smaller width */
  padding: 6px 10px;          /* reduced height */
  font-size: 14px;            /* slightly smaller text */
  border: 1px solid #ccc;
  border-radius: 10px;        /* cute rounded shape */
  outline: none;
  transition: 0.2s;
  background: #fafafa;        /* soft cute look */
}

/* Cute hover & focus effect */
.search-bar input:focus {
  border-color: #999;
  background: #fff;
  box-shadow: 0 0 4px rgba(0,0,0,0.1);
}


.search-bar input:focus {
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(75, 42, 173, 0.1);
}
@media (max-width: 600px) {
  .search-bar {
    width: 50%;             /* narrower on small screens */
    margin-left: auto;      /* push container to the right */
    justify-content: flex-end;
    padding-right: 10px;
  }

  .search-bar input {
    width: 50px !important; /* force small width */
    padding: 5px 8px;
    font-size: 12px;
  }
}

/* Flex container for profile picture + info */
.profile-header-flex {
  display: flex;
  flex-direction: column; /* stack on mobile */
  align-items: center;
  gap: 20px;
}

/* Profile picture section with followers below */
.profile-picture-section {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.follow-info-horizontal {
  display: flex;
  justify-content: center;
  gap: 20px;
  margin-top: 10px;
}

.follow-item {
  text-align: center;
}

/* Profile info on the right */
.profile-info-right {
  display: flex;
  flex-direction: column;
  gap: 10px;
  text-align: left;
    line-height: 0.95; /* tighten lines */
      margin-left: 10px; /* move closer to the profile picture */
}
.profile-info-right p {
  margin: 4px 0; /* small vertical spacing between lines */
}

/* Desktop layout */
@media (min-width: 900px) {
  .profile-header-flex {
    flex-direction: row; /* picture on left, info on right */
    align-items: flex-start;
  }

  .profile-picture-section {
    align-items: center;
  }

  .profile-info-right {
    margin-left: 40px; /* space between picture and info */
  }
}
@media (min-width: 900px) {
  .profile-info-right {
    margin-left: 20px; /* tighter spacing on desktop */
  }
}
/* Move followers/following to the left on desktop */
@media (min-width: 900px) {
  .follow-info-horizontal {
    justify-content: flex-start; /* align to the left instead of center */
    margin-left: 0;              /* remove extra margin if any */
  }
}
.interaction-panel ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.interaction-panel li {
  padding: 10px 0;
  border-bottom: 1px solid #eee;
}

.interaction-panel li a {
  display: flex;
  align-items: center;
  gap: 10px;
  text-decoration: none;  /* remove underline */
  color: var(--text);
  width: 100%;
  transition: 0.2s;
}

.interaction-panel li a:hover {
  color: var(--primary);
  background: #f7f5ff;
  border-radius: 8px;
  padding-left: 10px;
}
/* Full-width horizontal profile stats */
.profile-stats-section {
  width: 100%;               /* Take full page width */
  background: #fff;          /* Optional background */
  padding: 20px 40px;        /* Some spacing */
  margin: 40px 0;            /* Top & bottom spacing */
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  display: flex;
  gap: 30px;                 /* Space between panels */
  overflow-x: auto;          /* Allow horizontal scrolling if screen is small */
  box-sizing: border-box;    /* Include padding in width */
}

/* Each panel item inside stats */
.interaction-panel-horizontal {
  display: flex;
  gap: 40px;
}

.panel-item {
  min-width: 200px;          /* Ensure panels don‚Äôt collapse */
  flex: 1;                   /* Equal width stretch */
  background: #f7f5ff;       /* Optional distinct background */
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.05);
}

/* Level bar */
.level-bar {
  width: 100%;
  height: 12px;
  background: #ddd;
  border-radius: 6px;
  margin-top: 8px;
}
#levelProgress {
  height: 100%;
  background: var(--primary);
  border-radius: 6px;
}


/* Make sure the horizontal profile stats are responsive */
.profile-stats-section {
  width: 100%;
  background:  #f7f5ff;
  padding: 20px 40px;
  margin: 40px 0;
  box-shadow: 0 4px 12px  #f7f5ff;
  display: flex;
  overflow-x: auto;
  gap: 30px;
  box-sizing: border-box;
}

.interaction-panel-horizontal {
  display: flex;
  gap: 30px;
}

.panel-item {
  min-width: 220px;
  flex: 1;
  background: #f7f5ff;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 2px 8px  #B8860B;
}

.badges-container img {
  width: 40px;
  height: 40px;
}

/* Shift the profile layout slightly to the right */
.profile-layout {
  margin-left: 40px; /* adjust px as needed */
}

/* Shift the horizontal stats section to the right as well */
.profile-stats-section {
  margin-left: 70px; /* match the layout shift */
  margin-right: 40px; /* optional: keeps spacing consistent on the right */
}

/* Optional: shift poems section as well */
.profile-poems {
  margin-left: 40px; /* aligns poems with profile layout */
  margin-right: 40px; 
}

.top-poem-link {
  display: block;
  color:  #B8860B;
  text-decoration: none;
  margin: 6px 0;
  font-weight: 600;
  transition: color 0.2s ease;
}

.top-poem-link:hover {
  color: #1a73e8;
}
.profile-picture img {
  width: 180px;           /* üî• bigger circle size */
  height: 180px;
  border-radius: 50%;
  object-fit: cover;
  object-position: center;
  border: 4px solid #ccc;
  box-shadow: 0 0 15px rgba(0,0,0,0.15);
  image-rendering: high-quality;
  transition: transform 0.3s ease;
}

.profile-picture img:hover {
  transform: scale(1.05); /* subtle hover zoom for polish */
}


/* --- Image Modal --- */
.image-modal {
  display: none; /* Hidden by default */
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0,0,0,0.85);
  backdrop-filter: blur(3px);
  align-items: center;
  justify-content: center;
}

.image-modal img {
  max-width: 90%;
  max-height: 90%;
  border-radius: 12px;
  box-shadow: 0 0 30px rgba(255,255,255,0.2);
  animation: zoomIn 0.3s ease;
}

.close-modal {
  position: absolute;
  top: 20px;
  right: 40px;
  color: white;
  font-size: 40px;
  font-weight: bold;
  cursor: pointer;
  transition: 0.2s;
}

.close-modal:hover {
  color: #ff6666;
}

@keyframes zoomIn {
  from { transform: scale(0.9); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}
#topPoemContent span {
  display: block;
  margin-bottom: 4px;
}

.logout-nav-btn {
  display: inline-block;
  margin-left: 20px;
  padding: 6px 12px;
  font-size: 14px;
  background: var(--primary);
  color: #fff;
  border-radius: 8px;
  border: none;
  cursor: pointer;
  z-index: 50; /* ensure it‚Äôs above other elements */
}

.logout-nav-btn:hover {
  background: #6c3ddd;
}

.nav-right {
  display: flex;
  align-items: center;
  gap: 10px;
}
/* Move "My Profile" to left edge on small screens */
@media (max-width: 899px) {
  .profile-container {

 
    text-align: left;   /* align text left */
        width: 80%;         /* full width */
           font-size: 0.9rem; /* smaller text */
             background-color: #4b2aad; /* new background color */
  }

  .profile-header-flex {
    align-items: flex-start; /* align picture + info to left */
  }

  .profile-info-right {
    margin-left: 15px; /* small spacing from profile picture */
    text-align: left;
  }

  .profile-picture-section {
    align-items: flex-start; /* move picture to left */
  }

  .follow-info-horizontal {
    justify-content: flex-start; /* followers left-aligned */
  }
  
}

/* Small screens (keep info to the right of image) */
@media (max-width: 899px) {
  .profile-header-flex {
    flex-direction: row; /* side by side */
    align-items: flex-start; /* top-aligned */
    justify-content: flex-start; /* optional */
    gap: 15px; /* space between image and info */
  }

  .profile-picture-section {
    flex-shrink: 0; /* prevent shrinking */
  }

  .profile-info-right {
    margin-left: 0; /* spacing handled by gap */
    text-align: left;
  }
  
}
@media (max-width: 899px) {
  .profile-picture {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: flex-start; /* force left alignment */
    padding-bottom: 0; /* optional, remove extra space */
  }

  #changePicBtn {
    position: absolute;
    bottom: -10px;  /* adjust vertical position */
    left: 0 !important; /* force left alignment */
    width: 110px; /* reduce width */
    font-size: 0.7rem; /* smaller text */
    padding: 5px 10px; /* adjust padding */
  }
}

@media (max-width: 899px) {
  #editProfileBtn {
    font-size: 0.8rem;      /* smaller text */
    padding: 5px 10px;      /* smaller button */
    width: auto;            /* optional: shrink to content */
  }
}

@media (max-width: 600px) {
  h2 {
    font-size: 1.2rem;
    text-align: center;
  }
}

@media (max-width: 600px) {
  .nav-logo-img {
    width: 40px;  /* smaller logo image */
  }

  .logo-text {
    font-size: 1rem; /* smaller text */
  }

  .logo {
    margin-left: 10px; /* optional, keep it from touching the edge */
  }
}
/* Shift title and author slightly to the right */
.poem-title,
.poem-author {
  margin-left: 15px; /* adjust as needed */
}

/* Reduce width of comment input and align with card */
.comment-aligned {
  display: flex;
  align-items: center;
  gap: 8px; /* space between inputs and buttons */
  margin-left: 15px; /* same offset as title/author */
}

.comment-aligned .comment-input {
  flex: 1;       /* input takes remaining space */
  max-width: 200px; /* reduced width */
  padding: 6px 10px;
  border-radius: 6px;
  border: 1px solid #ccc;
  font-size: 0.9rem;
}

</style>
</head>

<body>
<header>
  <nav>
    <div class="logo">
      <img src="images/logo.png" alt="Volant Poetry Logo" class="nav-logo-img">
      <span class="logo-text">
        <span class="logo-highlight">Volant</span> Poetry
      </span>
    </div>

    <div class="nav-links" id="nav-links">
      <span class="close-btn" id="close-btn">‚úï</span>
      <a href="index.html">Home</a>
      <a href="about.html">About</a>
       <a href="contact.html">Contact Us</a> <!-- ‚úÖ New link -->
    </div>
<div class="nav-right">

<!-- Mobile Icons -->
    <div class="mobile-icons">
  <!-- Logout Button -->
  <button id="logoutBtnNav" class="btn logout-nav-btn">Logout</button>
  </div>

      <div class="menu-toggle" id="menu-toggle">‚ò∞</div>
    </div>
</nav>
</header>

<!-- PROFILE + QUICK ACCESS WRAPPER -->
<div class="profile-layout">

  <!-- Profile Container (Left Column) -->
  <div class="profile-container">
    <h2>Profile</h2>

    <div class="profile-header-flex">
      <div class="profile-picture-section">
        <div class="profile-picture">
          <img id="profilePic" src="images/default-avatar.png" alt="Profile Picture">
          <input type="file" id="uploadPic" style="display:none;">
          <button class="btn" id="changePicBtn">Change Picture</button>
        </div>

        <div class="follow-info-horizontal">
          <div class="follow-item">
            <strong id="followersCount">0</strong>
            <span>Followers</span>
          </div>
          <div class="follow-item">
            <strong id="followingCount">0</strong>
            <span>Following</span>
          </div>
        </div>
      </div>

      <div class="profile-info-right">
        <p><strong>Username:</strong> <span id="username"></span></p>
        <p><strong>Email:</strong> <span id="email"></span></p>
        <p><strong>Bio:</strong> <span id="bio"></span></p>
        <p><strong>Joined:</strong> <span id="joined"></span></p>
        <div class="profile-buttons">
          <button class="btn" id="editProfileBtn">Edit Profile</button>
   
        </div>
      </div>
    </div>
  </div>

  <!-- Quick Access (Right Column) -->
  <div class="interaction-panel">
    <h3>Quick Access</h3>
    <ul>
      <li><a href="notifications.html">üîî Notifications</a></li>
      <li><a href="messages.html">‚úâ Messages</a></li>
      <li><a href="account-preferences.html">‚öô Account Preferences</a></li>
        <li><a href="submitpoems.html">üìù Submit Poems</a></li>
    </ul>
  </div>

</div>

<!-- HORIZONTAL PROFILE STATS (Full Width Section) -->
<section class="profile-stats-section">
  <div class="interaction-panel-horizontal">

    <div class="panel-item">
      <h3>Level</h3>
      <strong>Level:</strong> <span id="userLevel"></span>
      <div class="level-bar">
        <div id="levelProgress" style="width:0%"></div>
      </div>
    </div>

    <div class="panel-item">
      <h3>Achievements</h3>
      <div class="badges-container">
      </div>
    </div>

    <div class="panel-item">
      <h3>Stats</h3>
      <ul>
        <li>Poems Submitted: <span id="poemCount"></span></li>
        <li>Total Likes: <span id="likeCount"></span></li>
        <li>Total Comments: <span id="commentCount"></span></li>
      </ul>
    </div>

    <div class="panel-item">
      <h3>3 Top Poems</h3>
      <div class="top-poem">
        <p id="topPoemContent"></p>
      </div>
    </div>

  </div>
</section>

<!-- Fullscreen image modal -->
<div id="imageModal" class="image-modal">
  <span class="close-modal">&times;</span>
  <img class="modal-content" id="expandedImg">
</div>

<!-- POEMS SECTION -->
<div class="profile-poems">
  <h2>My Submitted Poems</h2>
  <!-- üîç Search Bar -->
 <div class="search-bar">
  <input 
    type="text" 
    id="searchInput" 
    placeholder="Search poems..."
    autocomplete="on"
  >
</div>


  <div id="poemsContainer">
    <p class="empty-message"></p>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { 
  getFirestore, doc, getDoc, setDoc, updateDoc, 
  collection, query, where, getDocs, onSnapshot, runTransaction 
} from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
import { getStorage } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-storage.js";

const firebaseConfig = {
  apiKey: "AIzaSyC4DHI8aBVY4JjTvJ-r-TGIDPsewtEWxzU",
  authDomain: "silent-depth.firebaseapp.com",
  projectId: "silent-depth",
  storageBucket: "silent-depth.appspot.com",
  messagingSenderId: "78008755450",
  appId: "1:78008755450:web:3fd0f0f298a08820935543"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);
const storage = getStorage(app);

// --- Get ?uid from URL ---
const urlParams = new URLSearchParams(window.location.search);
const profileUid = urlParams.get("uid"); // null if it's your profile

// --- DOM elements ---
const usernameSpan = document.getElementById("username");
const emailSpan = document.getElementById("email");
const bioSpan = document.getElementById("bio");
const joinedSpan = document.getElementById("joined");
const profilePic = document.getElementById("profilePic");
const logoutBtn = document.getElementById("logoutBtn");
const editBtn = document.getElementById("editProfileBtn");
const changePicBtn = document.getElementById("changePicBtn");
const uploadPic = document.getElementById("uploadPic");
const poemsContainer = document.getElementById("poemsContainer");
const topPoemsContainer = document.getElementById("topPoems");
const rankingContainer = document.getElementById("ranking-poets-container"); // your leaderboard container

let actorUsername = "";   // logged-in user's username (for actions/notifications)
let profileUsername = ""; // the username of the profile being viewed (whose poems we show)
let viewingOwnProfile = false;

// --- Truncate poems by number of lines ---
function truncatePoemByLines(text, maxLines = 8) {
  const lines = text.split(/\r?\n/);
  const truncated = lines.slice(0, maxLines).join("\n");
  return {
    preview: truncated + (lines.length > maxLines ? "\n..." : ""),
    full: text,
    truncated: lines.length > maxLines
  };
}

// --- Update Achievements & Level (same as before) ---
function updateAchievements(poemCount, totalLikes, totalCommentsReceived, totalCommentsMade) {
  const badgesContainer = document.querySelector(".badges-container");
  if (!badgesContainer) return;
  badgesContainer.innerHTML = "";
  const badges = [];
  if (poemCount >= 5) badges.push({ src: "images/LOGO R.jpg", title: "Poet Starter" });
  if (totalLikes >= 15) badges.push({ src: "images/badge-likes.png", title: "Loved by Many" });
  if (totalCommentsReceived >= 10) badges.push({ src: "images/logo.png", title: "Engaging Poet" });
  if (totalCommentsMade >= 15) badges.push({ src: "images/badge-active.png", title: "Active Commenter" });
  badges.forEach(badge => {
    const img = document.createElement("img");
    img.src = badge.src;
    img.title = badge.title;
    badgesContainer.appendChild(img);
  });
}

function updateLevel(poemCount, totalLikes, totalCommentsReceived, totalCommentsMade) {
  let score = 0;
  score += Math.min(poemCount * 2, 25);
  score += Math.min(totalLikes, 25);
  score += Math.min(totalCommentsReceived * 2.5, 25);
  score += Math.min(totalCommentsMade * 1.66, 25);
  const level = Math.floor(score / 20) + 1;
  const progress = Math.min((score % 20) * 5, 100);
  const levelEl = document.getElementById("userLevel");
  const levelProgressEl = document.getElementById("levelProgress");
  if (levelEl) levelEl.textContent = level;
  if (levelProgressEl) levelProgressEl.style.width = progress + "%";
}

// ---------------------- Ranking Poets (weekly leaderboard) ----------------------
async function loadRankingPoets() {
  try {
    if (!rankingContainer) return; // no container, skip

    const poetsMap = {}; // { uniqueUsername: { username, poemsWritten, likesReceived, commentsReceived, likesGiven, commentsGiven, score } }

    const now = new Date();
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

    const poemsSnapshot = await getDocs(collection(db, "recentPoems"));
    const usersSnapshot = await getDocs(collection(db, "users"));

    // Initialize poets from users collection
    usersSnapshot.forEach(userDoc => {
      const data = userDoc.data();
      const username = data.username || "Anonymous";
      poetsMap[username] = {
        userId: userDoc.id,
        username,
        poemsWritten: 0,
        likesReceived: 0,
        commentsReceived: 0,
        likesGiven: 0,
        commentsGiven: 0,
        score: 0
      };
    });

    // Count activity in the past week
    poemsSnapshot.forEach(docSnap => {
      const data = docSnap.data();

      // Normalize a unique key using submittedBy or username
      const submittedBy = data.submittedBy || data.username || data.author || "Anonymous";

      if (!poetsMap[submittedBy]) {
        poetsMap[submittedBy] = {
          userId: data.userId || null,
          username: submittedBy,
          poemsWritten: 0,
          likesReceived: 0,
          commentsReceived: 0,
          likesGiven: 0,
          commentsGiven: 0,
          score: 0
        };
      }

      const createdAt = data.timestamp ? (data.timestamp.toDate ? data.timestamp.toDate() : new Date(data.timestamp)) : new Date();
      if (createdAt >= weekAgo) {
        poetsMap[submittedBy].poemsWritten += 1;
        poetsMap[submittedBy].likesReceived += data.likes || 0;
        poetsMap[submittedBy].commentsReceived += Array.isArray(data.comments) ? data.comments.length : (data.commentsCount || 0);
      }

      // Likes given
      if (data.likedBy && Array.isArray(data.likedBy)) {
        data.likedBy.forEach(uid => {
          const user = usersSnapshot.docs.find(u => u.id === uid);
          const likerName = user ? (user.data().username || "Anonymous") : "Anonymous";

          if (!poetsMap[likerName]) {
            poetsMap[likerName] = {
              userId: uid,
              username: likerName,
              poemsWritten: 0,
              likesReceived: 0,
              commentsReceived: 0,
              likesGiven: 0,
              commentsGiven: 0,
              score: 0
            };
          }
          poetsMap[likerName].likesGiven += 1;
        });
      }

      // Comments given
      if (data.comments && Array.isArray(data.comments)) {
        data.comments.forEach(comment => {
          const commenterName = comment.user || comment.userId || "Anonymous";

          if (!poetsMap[commenterName]) {
            poetsMap[commenterName] = {
              userId: comment.userId || null,
              username: commenterName,
              poemsWritten: 0,
              likesReceived: 0,
              commentsReceived: 0,
              likesGiven: 0,
              commentsGiven: 0,
              score: 0
            };
          }
          poetsMap[commenterName].commentsGiven += 1;
        });
      }
    });

    // Calculate score
    Object.values(poetsMap).forEach(poet => {
      poet.score = poet.poemsWritten * 5 +
                   poet.likesReceived * 3 +
                   poet.commentsReceived * 2 +
                   poet.likesGiven +
                   poet.commentsGiven;
    });

    // Sort and take top 20
    const sortedPoets = Object.values(poetsMap)
      .filter(poet => poet.score > 0)
      .sort((a, b) => b.score - a.score)
      .slice(0, 20);

    // Render
    rankingContainer.innerHTML = "";
    sortedPoets.forEach((poet, index) => {
      const poetDiv = document.createElement("div");
      poetDiv.className = "ranking-poet";

      // Top 3 badges
      let badge = "";
      if (index === 0) badge = "üèÜ";
      else if (index === 1) badge = "ü•à";
      else if (index === 2) badge = "ü•â";

      poetDiv.innerHTML = `
        <a href="user-profile.html?uid=${encodeURIComponent(poet.userId || "")}" class="poet-link">
          ${badge} ${poet.username}
        </a>
        <p style="margin:4px 0; font-size:0.9rem; color:#555;">
          Activity this week: ${poet.poemsWritten} poems ¬∑ ${poet.likesReceived} likes ¬∑ ${poet.commentsReceived} comments
        </p>
      `;
      rankingContainer.appendChild(poetDiv);
    });

  } catch (err) {
    console.error("Error loading ranking poets:", err);
  }
}
// -------------------------------------------------------------------------------

// --- Auth handling ---
onAuthStateChanged(auth, async (user) => {
  if (!user) {
    window.location.href = "users-login.html";
    return;
  }

  // Fetch actor (logged-in) user's doc to know their username for actions
  const actorRef = doc(db, "users", user.uid);
  let actorDoc = await getDoc(actorRef);
  if (!actorDoc.exists()) {
    await setDoc(actorRef, {
      username: user.displayName || user.email.split("@")[0],
      email: user.email,
      bio: "",
      joined: new Date(),
      photoURL: user.photoURL || ""
    });
    actorDoc = await getDoc(actorRef);
  }
  const actorData = actorDoc.data();
  actorUsername = actorData.username || user.email.split("@")[0];

  // Determine if we are viewing our own or another user‚Äôs profile
  viewingOwnProfile = !profileUid || profileUid === user.uid;
  const targetUid = viewingOwnProfile ? user.uid : profileUid;

  // Load the target profile's data (profileUsername etc.)
  const userRef = doc(db, "users", targetUid);
  const userDoc = await getDoc(userRef);

  if (!userDoc.exists()) {
    alert("User not found.");
    window.location.href = "index.html";
    return;
  }

  const data = userDoc.data();
  profileUsername = data.username || data.email.split("@")[0];

  if (usernameSpan) usernameSpan.textContent = profileUsername;
  if (emailSpan) emailSpan.textContent = data.email || "";
  if (bioSpan) bioSpan.textContent = data.bio || "No bio yet";
  if (joinedSpan) {
    joinedSpan.textContent = data.joined
      ? (data.joined.seconds
          ? new Date(data.joined.seconds * 1000).toDateString()
          : new Date(data.joined).toDateString())
      : "Unknown";
  }
  if (profilePic) profilePic.src = data.photoURL || "images/default-avatar.png";

  // If it's someone else's profile ‚Üí disable editing (but still allow likes/comments on poems)
  if (!viewingOwnProfile) {
    if (editBtn) editBtn.style.display = "none";
    if (changePicBtn) changePicBtn.style.display = "none";
    if (uploadPic) uploadPic.style.display = "none";
    document.getElementById("logoutBtn")?.remove();
  }
// If it's someone else's profile ‚Üí hide Quick Access menu
if (!viewingOwnProfile) {
  const quickAccessPanel = document.querySelector(".interaction-panel");
  if (quickAccessPanel) {
    quickAccessPanel.style.display = "none";
  }
}

  // Fetch profile's poems and top poems
  await fetchUserPoems(profileUsername);
  await fetchTopPoems(profileUsername);

  // Load ranking poets (optional leaderboard) ‚Äî only once after user loads
  await loadRankingPoets();
});

// --- Fetch User Poems (for profile being viewed) ---
async function fetchUserPoems(usernameToFetch) {
  try {
    const q = query(collection(db, "recentPoems"), where("submittedBy", "==", usernameToFetch));
    const querySnap = await getDocs(q);
    const container = poemsContainer;
    container.innerHTML = "";

    let totalLikes = 0;
    let totalCommentsReceived = 0;
    let poemCount = querySnap.size;
    let totalCommentsMade = 0;

    if (querySnap.empty) {
      container.innerHTML = `<p class="empty-message">No poems yet.</p>`;
    } else {
      for (const docSnap of querySnap.docs) {
        const poem = docSnap.data();
        const docId = docSnap.id;
        const card = document.createElement("div");
        card.className = "recent-poem-card";
        card.dataset.id = docId;

        const truncated = truncatePoemByLines(poem.content, 8);
        const likes = typeof poem.likes === "number" ? poem.likes : 0;
        totalLikes += likes;

        // comments subcollection may be present as subcollection
        let commentsSnapCount = 0;
        try {
          const commentsSnap = await getDocs(collection(db, "recentPoems", docId, "comments"));
          commentsSnapCount = commentsSnap.size;
        } catch (err) {
          commentsSnapCount = Array.isArray(poem.comments) ? poem.comments.length : 0;
        }
        totalCommentsReceived += commentsSnapCount;

        // Make author clickable ‚Äî link to their profile page by uid if available, else by submittedBy
        const authorLink = poem.submittedByUid
          ? `<a href="user-profile.html?uid=${encodeURIComponent(poem.submittedByUid)}" class="author-link">${poem.author || poem.submittedBy || usernameToFetch}</a>`
          : `<a href="user-profile.html?user=${encodeURIComponent(poem.submittedBy || usernameToFetch)}" class="author-link">${poem.author || poem.submittedBy || usernameToFetch}</a>`;

card.innerHTML = `
  <div class="poem-display">
    <h3 class="poem-title">${poem.title}</h3>
    <div class="poem-body">
      <p class="poem-content">${truncated.preview.replace(/\n/g, "<br>")}</p>
      ${truncated.truncated ? `<button class="read-more-btn">Show More</button>` : ""}
    </div>
  </div>
  ${poem.categories && poem.categories.length > 0 ? `<p class="poem-category-line"><em>${poem.categories.join(", ")}</em></p>` : ""}
  <div class="poem-actions comment-aligned">
    <textarea class="comment-input" placeholder="Write a comment..." rows="1"></textarea>
    <button class="comment-btn">Post</button>
    <button class="like-btn">
      ‚ù§Ô∏è <span class="like-count">${likes}</span>
    </button>
    <span class="message-count">üí¨ ${commentsSnapCount}</span>
  </div>
  <div class="comment-list" style="display:none;"></div>
`;

        container.appendChild(card);
      }
    }

    const poemCountEl = document.getElementById("poemCount");
    const likeCountEl = document.getElementById("likeCount");
    const commentCountEl = document.getElementById("commentCount");
    if (poemCountEl) poemCountEl.textContent = poemCount;
    if (likeCountEl) likeCountEl.textContent = totalLikes;
    if (commentCountEl) commentCountEl.textContent = totalCommentsReceived;

    updateAchievements(poemCount, totalLikes, totalCommentsReceived, totalCommentsMade);
    updateLevel(poemCount, totalLikes, totalCommentsReceived, totalCommentsMade);
  } catch (err) {
    console.error("Error fetching poems:", err);
    if (poemsContainer) poemsContainer.innerHTML = `<p class='empty-message'>Error loading poems.</p>`;
  }
}

// üíå Helper: Add notification for the poem owner
async function addNotification(poemId, poemOwnerUid, type, fromUser, text = "") {
  if (!poemOwnerUid || !auth.currentUser) return; // don't notify if missing
  if (poemOwnerUid === auth.currentUser.uid) return; // don't notify self

  const userRef = doc(db, "users", poemOwnerUid);
  try {
    await runTransaction(db, async (tx) => {
      const userSnap = await tx.get(userRef);
      if (!userSnap.exists()) return;

      const data = userSnap.data();
      const notifications = Array.isArray(data.notifications) ? data.notifications : [];

      notifications.push({
        type,               // "like" or "comment"
        from: fromUser,     // username of the actor
        poemId,             // which poem
        text,               // comment text (if any)
        read: false,
        timestamp: new Date()
      });

      tx.update(userRef, { notifications });
    });
  } catch (err) {
    console.error("Failed to add notification:", err);
  }
}

// ‚úÖ Unified click listener for poems container (likes, comments, read more)
poemsContainer.addEventListener("click", async (e) => {
  const card = e.target.closest(".recent-poem-card");
  if (!card) return;
  const poemId = card.dataset.id;
  if (!poemId) return;

  const currentUser = auth.currentUser;

  // ‚ù§Ô∏è LIKE BUTTON ‚Äî each user can like only once
  if (e.target.classList.contains("like-btn")) {
    const likeBtn = e.target;
    const countEl = card.querySelector(".like-count");
    if (!countEl) return;

    if (!currentUser) {
      alert("Please sign in to like poems.");
      return;
    }
    const userUid = currentUser.uid;
    likeBtn.disabled = true;
    const prevText = likeBtn.textContent;

    try {
      const poemRef = doc(db, "recentPoems", poemId);
      await runTransaction(db, async (tx) => {
        const snap = await tx.get(poemRef);
        if (!snap.exists()) throw new Error("DOC_NOT_FOUND");

        const data = snap.data();
        const likedBy = Array.isArray(data.likedBy) ? data.likedBy : [];
        const currentLikes = typeof data.likes === "number" ? data.likes : 0;

        if (likedBy.includes(userUid)) throw new Error("ALREADY_LIKED");

        tx.update(poemRef, {
          likes: currentLikes + 1,
          likedBy: [...likedBy, userUid],
        });
      });

      const prevCount = parseInt(countEl.textContent) || 0;
      countEl.textContent = prevCount + 1;
      likeBtn.classList.add("liked");
      likeBtn.textContent = "‚ù§Ô∏è Liked";
      likeBtn.style.pointerEvents = "none";

      // Add notification for poem owner
      const poemSnap = await getDoc(doc(db, "recentPoems", poemId));
      const poemOwner = poemSnap.data().submittedByUid || poemSnap.data().uid;
      await addNotification(poemId, poemOwner, "like", actorUsername);

    } catch (err) {
      console.error("Like transaction failed:", err);

      if (err.message === "ALREADY_LIKED") {
        likeBtn.classList.add("liked");
        likeBtn.textContent = "‚ù§Ô∏è Liked";
        likeBtn.style.pointerEvents = "none";
        alert("You‚Äôve already liked this poem.");
      } else if (err.message === "DOC_NOT_FOUND") {
        alert("This poem no longer exists.");
      } else if (err.code === "permission-denied") {
        alert("You don't have permission to like this poem (security rules).");
      } else {
        alert("Could not like the poem. Try again.");
      }

      if (err.message !== "ALREADY_LIKED") {
        likeBtn.disabled = false;
        likeBtn.textContent = prevText;
      }
    }
  }
// SHOW COMMENTS
if (e.target.classList.contains("message-count")) {
  const card = e.target.closest(".recent-poem-card");
  const docId = card.dataset.id;
  const commentList = card.querySelector(".comment-list");

  // Toggle visibility
  const isVisible = commentList.style.display === "block";
  commentList.style.display = isVisible ? "none" : "block";
  if (isVisible) return;

  commentList.innerHTML = "<p style='color:#888;'>Loading comments...</p>";

  try {
    const commentsCol = collection(db, "recentPoems", docId, "comments");
    const commentsSnapshot = await getDocs(commentsCol);
    commentList.innerHTML = ""; // clear loading text

    if (commentsSnapshot.empty) {
      commentList.innerHTML = "<p style='color:#888;'>No comments yet.</p>";
      return;
    }

    // Get poem owner ID
    const poemRef = doc(db, "recentPoems", docId);
    const poemSnap = await getDoc(poemRef);
    const poemOwnerId = poemSnap.exists() ? poemSnap.data().authorId || poemSnap.data().userId : null;

    // Sort comments by timestamp ascending
    const comments = commentsSnapshot.docs.map(d => ({ id: d.id, ...d.data() }));
    comments.sort((a, b) => {
      const ta = a.timestamp?.toMillis?.() || 0;
      const tb = b.timestamp?.toMillis?.() || 0;
      return ta - tb;
    });

    // Display comments
    for (const c of comments) {
      let displayName = c.user || "Anonymous";
      let userLink = "#";
      if (c.userId) {
        try {
          const userDoc = await getDoc(doc(db, "users", c.userId));
          if (userDoc.exists()) {
            displayName = userDoc.data().username || displayName;
            userLink = `/user-profile.html?uid=${c.userId}`;
          }
        } catch {}
      }

      const div = document.createElement("div");
      div.className = "comment";
      div.dataset.commentId = c.id;
      div.style.cssText = "background:#fff; padding:8px 12px; margin:6px 0; border-radius:6px;";

      div.innerHTML = `
        <a href="${userLink}" style="font-weight:600; color:#a67c52; text-decoration:none; margin-right:6px;">${displayName}</a>: ${c.text}
        <div class="comment-actions" style="margin-top:4px;">
          <small class="reply-toggle" style="color:#5a3cb3; cursor:pointer;">Reply</small>
        </div>
        <div class="reply-section" style="margin-left:20px; margin-top:6px;"></div>
      `;

      commentList.appendChild(div);

      // Load existing replies
      const repliesCol = collection(db, "recentPoems", docId, "comments", c.id, "replies");
      const repliesSnapshot = await getDocs(repliesCol);
      if (!repliesSnapshot.empty) {
        const replySection = div.querySelector(".reply-section");
        repliesSnapshot.forEach(r => {
          const reply = r.data();
          replySection.innerHTML += `
            <div style="background:#f7f7f7; padding:6px 10px; border-radius:6px; margin:4px 0;">
              <a href="/user-profile.html?uid=${reply.userId}" style="font-weight:600; color:#5a3cb3; text-decoration:none;">${reply.username}</a>: ${reply.text}
            </div>
          `;
        });
      }
    }
  } catch (err) {
    console.error("Error loading comments:", err);
    commentList.innerHTML = "<p style='color:red;'>Failed to load comments.</p>";
  }
}

// REPLY TOGGLE ‚Äî show input box when ‚ÄúReply‚Äù is clicked
if (e.target.classList.contains("reply-toggle")) {
  const commentDiv = e.target.closest(".comment");
  const replySection = commentDiv.querySelector(".reply-section");

  // If already open, close it
  const existing = replySection.querySelector(".reply-input");
  if (existing) {
    existing.remove();
    return;
  }

  const inputContainer = document.createElement("div");
  inputContainer.className = "reply-input";
  inputContainer.innerHTML = `
    <textarea placeholder="Write a reply..." rows="1" style="width:95%; border-radius:6px; padding:6px; border:1px solid #ccc;"></textarea>
    <button class="send-reply-btn" style="margin-top:4px; background:#5a3cb3; color:white; border:none; border-radius:6px; padding:4px 10px; cursor:pointer;">Send</button>
  `;
  replySection.appendChild(inputContainer);
}

// SEND REPLY ‚Äî handle send button click
if (e.target.classList.contains("send-reply-btn")) {
  const user = auth.currentUser;
  if (!user) { alert("Please sign in to reply."); return; }

  const commentDiv = e.target.closest(".comment");
  const card = e.target.closest(".recent-poem-card");
  const docId = card.dataset.id;
  const commentId = commentDiv.dataset.commentId;
  const textarea = commentDiv.querySelector(".reply-input textarea");
  const replyText = textarea.value.trim();
  if (!replyText) return;

  const replySection = commentDiv.querySelector(".reply-section");

  try {
    const userDoc = await getDoc(doc(db, "users", user.uid));
    const username = userDoc.exists() ? userDoc.data().username || "User" : "User";

    await addDoc(collection(db, "recentPoems", docId, "comments", commentId, "replies"), {
      userId: user.uid,
      username,
      text: replyText,
      timestamp: new Date()
    });

    // Append instantly
    replySection.innerHTML += `
      <div style="background:#f7f7f7; padding:6px 10px; border-radius:6px; margin:4px 0;">
        <a href="/user-profile.html?uid=${user.uid}" style="font-weight:400; color:#5a3cb3; text-decoration:none;">${username}</a>: ${replyText}
      </div>
    `;
    textarea.value = "";
  } catch (err) {
    console.error("Error sending reply:", err);
    alert("Failed to send reply.");
  }
}

  // üìù POST COMMENT
  if (e.target.classList.contains("comment-btn")) {
    const input = card.querySelector(".comment-input");
    const text = input.value.trim();
    if (!text) return alert("Comment cannot be empty.");

    if (!auth.currentUser) {
      alert("Please sign in to comment.");
      return;
    }

    try {
      const commentsRef = collection(db, "recentPoems", poemId, "comments");
      await setDoc(doc(commentsRef), {
        text,
        user: actorUsername,
        userId: auth.currentUser.uid,
        createdAt: new Date(),
      });

      input.value = "";
      const messageCount = card.querySelector(".message-count");
      const currentCount =
        parseInt((messageCount?.textContent || "").replace("üí¨", "")) || 0;
      if (messageCount) messageCount.textContent = `üí¨ ${currentCount + 1}`;

      const commentList = card.querySelector(".comment-list");
      if (commentList.style.display === "block") {
        const p = document.createElement("p");
        p.innerHTML = `<strong>${actorUsername}:</strong> ${text}`;
        commentList.appendChild(p);
      }

      // Add notification for poem owner
      const poemSnap = await getDoc(doc(db, "recentPoems", poemId));
      const poemOwner = poemSnap.data().submittedByUid || poemSnap.data().uid;
      await addNotification(poemId, poemOwner, "comment", actorUsername, text);

    } catch (err) {
      console.error("Error posting comment:", err);
      alert("Failed to post comment.");
    }
  }

  // üëÅÔ∏è READ MORE toggle
  if (e.target.classList.contains("read-more-btn")) {
    const poemBody = card.querySelector(".poem-body");
    const poemContent = poemBody.querySelector(".poem-content");
    const isExpanded = e.target.textContent.includes("Less");

    const poemSnap = await getDoc(doc(db, "recentPoems", poemId));

    if (isExpanded) {
      const truncated = truncatePoemByLines(poemSnap.data().content, 8);
      poemContent.textContent = truncated.preview;
      e.target.textContent = "Show More";
    } else {
      poemContent.textContent = poemSnap.data().content;
      e.target.textContent = "Show Less";
    }
  }
});

// --- Fetch Top 3 Poems for this profile (clickable + numbering) ---
async function fetchTopPoems(profileName) {
  try {
    if (!profileName) return;

    const poemsRef = collection(db, "recentPoems");
    const q = query(poemsRef, where("submittedBy", "==", profileName));
    const snapshot = await getDocs(q);

    const topPoemContent = document.getElementById("topPoemContent");
    if (!topPoemContent) return;

    if (snapshot.empty) {
      topPoemContent.textContent = "No poems yet.";
      return;
    }

    const poems = [];

    snapshot.forEach((docSnap) => {
      const poem = docSnap.data();
      if (!poem.title) return;

      const likes = poem.likes || 0;
      const comments = Array.isArray(poem.comments) ? poem.comments.length : 0;
      const engagement = likes + comments;

      const slug = poem.slug || poem.title.toLowerCase().replace(/\s+/g, "-").replace(/[^\w-]+/g, "");
      poems.push({ slug, title: poem.title, engagement });
    });

    const top3 = poems.sort((a, b) => b.engagement - a.engagement).slice(0, 3);

    topPoemContent.innerHTML = top3.length
      ? top3
          .map(
            (p, i) =>
              `<div style="margin-bottom:4px;">
                <span style="display:inline;">${i + 1}.</span>
                <a href="poem.html?slug=${encodeURIComponent(p.slug)}" class="top-poem-link" style="display:inline;">${p.title}</a>
              </div>`
          )
          .join("")
      : "No top poems yet.";
  } catch (error) {
    console.error("Error fetching top poems:", error);
  }
}


// --- Cloudinary Upload (only for your own profile) ---
if (changePicBtn) {
  const cloudName = "dzoq4pgjn"; // your Cloudinary cloud name
  const uploadPreset = "profile_pics"; // must match your Cloudinary preset

  changePicBtn.addEventListener("click", () => {
    if (!viewingOwnProfile) return alert("You cannot change another user's picture.");
    uploadPic.click();
  });

  uploadPic.addEventListener("change", async (e) => {
    if (!viewingOwnProfile) return;
    const file = e.target.files[0];
    if (!file) return;

    const formData = new FormData();
    formData.append("file", file);
    formData.append("upload_preset", uploadPreset);

    try {
      const res = await fetch(`https://api.cloudinary.com/v1_1/${cloudName}/image/upload`, {
        method: "POST",
        body: formData
      });
      const data = await res.json();
      const imageUrl = data.secure_url.replace(
        '/upload/',
        '/upload/c_fill,g_auto,f_auto,q_auto:best,h_600,w_600,r_max,e_sharpen/'
      );

      // Update image instantly
      if (profilePic) profilePic.src = imageUrl;

      // Save to Firestore for persistence
      const user = auth.currentUser;
      if (user) {
        await updateDoc(doc(db, "users", user.uid), { photoURL: imageUrl });
      }

      console.log("‚úÖ Uploaded to Cloudinary:", imageUrl);
    } catch (err) {
      console.error("‚ùå Cloudinary upload error:", err);
    }
  });
}

// --- Profile picture expand on click ---
const modal = document.getElementById("imageModal");
const expandedImg = document.getElementById("expandedImg");
const closeModal = document.querySelector(".close-modal");
const profilePicEl = document.getElementById("profilePic");
if (profilePicEl) {
  profilePicEl.addEventListener("click", () => {
    if (expandedImg) expandedImg.src = profilePicEl.src;
    if (modal) modal.style.display = "flex";
  });
}
if (closeModal) {
  closeModal.addEventListener("click", () => {
    if (modal) modal.style.display = "none";
  });
}
window.addEventListener("click", (e) => {
  if (e.target === modal) modal.style.display = "none";
});

// Menu toggle and nav
const menuToggle = document.getElementById("menu-toggle");
const navLinks = document.getElementById("nav-links");
const closeBtn = document.getElementById("close-btn");

if (menuToggle) {
  menuToggle.addEventListener("click", () => {
    navLinks.classList.toggle("show");
  });
}
if (closeBtn) {
  closeBtn.addEventListener("click", () => {
    navLinks.classList.remove("show");
  });
}
// --- Logout Nav Button ---
const logoutBtnNav = document.getElementById("logoutBtnNav");
if (logoutBtnNav) {
  logoutBtnNav.addEventListener("click", async () => {
    if (!auth.currentUser) {
      alert("No user is logged in.");
      return;
    }
    try {
      await signOut(auth); // properly sign out
      window.location.href = "users-login.html";
    } catch (err) {
      console.error("Logout failed:", err);
      alert("Logout failed, try again.");
    }
  });
}

// --- Search Filter with Firestore ---
const searchInput = document.getElementById("searchInput");
let debounceTimeout;

// Keep track of poems already in the DOM to avoid duplicates
const loadedPoemIds = new Set(
  Array.from(document.querySelectorAll(".recent-poem-card")).map(
    card => card.dataset.id
  )
);

if (searchInput) {
  searchInput.addEventListener("input", () => {
    clearTimeout(debounceTimeout);
    debounceTimeout = setTimeout(async () => {
      const filter = searchInput.value.trim().toLowerCase();
      filterDOM(filter);
      await searchFirestore(filter);
    }, 300);
  });
}

// --- Filter poems already in the DOM ---
function filterDOM(filter) {
  const cards = document.querySelectorAll(".recent-poem-card");
  let anyVisible = false;

  cards.forEach(card => {
    const title = card.querySelector(".poem-title")?.textContent.toLowerCase() || "";
    const content = card.querySelector(".poem-content")?.textContent.toLowerCase() || "";
    const categories = (card.dataset.categories || "").toLowerCase();

    if (title.includes(filter) || content.includes(filter) || categories.includes(filter)) {
      card.style.display = "block";
      anyVisible = true;
    } else {
      card.style.display = "none";
    }
  });

  showEmptyMessage(!anyVisible);
}

// --- Firestore search ---
async function searchFirestore(filter) {
  if (!filter) return;

  const poemsRef = collection(db, "recentPoems");
  const snapshot = await getDocs(poemsRef);

  let anyNewResults = false;

  snapshot.docs.forEach(docSnap => {
    const data = docSnap.data();
    const id = docSnap.id;

    // Skip poems already in the DOM
    if (loadedPoemIds.has(id)) return;

    const title = (data.title || "").toLowerCase();
    const content = (data.content || "").toLowerCase();
    const categories = (data.categories || "").toLowerCase();

    if (title.includes(filter) || content.includes(filter) || categories.includes(filter)) {
      addPoemCardToDOM(id, data);
      loadedPoemIds.add(id);
      anyNewResults = true;
    }
  });

  // Update empty message if no poems visible
  const anyVisible = document.querySelectorAll(".recent-poem-card:not([style*='display: none'])").length > 0;
  showEmptyMessage(!anyVisible);
}

// --- Helper: add new poem card to DOM ---
function addPoemCardToDOM(id, data) {
  const container = document.getElementById("poemsContainer"); // make sure this ID matches your container
  if (!container) return;
  const card = document.createElement("div");
  card.className = "recent-poem-card";
  card.dataset.id = id;
  card.dataset.categories = data.categories || "";

  card.innerHTML = `
    <h3 class="poem-title">${data.title || ""}</h3>
    <p class="poem-content">${data.content || ""}</p>
  `;

  container.appendChild(card);
}

// --- Helper: show/hide empty message ---
function showEmptyMessage(show) {
  const container = document.getElementById("poemsContainer");
  if (!container) return;
  let msg = container.querySelector(".empty-message");
  if (show) {
    if (!msg) {
      msg = document.createElement("p");
      msg.className = "empty-message";
      container.appendChild(msg);
    }
    msg.textContent = "No poems match your search.";
  } else if (msg) {
    msg.textContent = "";
  }
}
</script>


</body>
</html>






