<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="robots" content="noindex, nofollow">
<title>Achievements Admin - Organized by Metrics</title>
<style>
  body { font-family: Arial, sans-serif; padding: 20px; background: #f7f7f7; }
  h1 { text-align: center; }
  h2 { margin: 30px 0 15px; padding-bottom: 8px; border-bottom: 2px solid #5a3cb3; }
  .category-summary { background: #e8e4f5; padding: 10px; border-radius: 6px; margin-bottom: 20px; font-size: 0.9em; }
  form { background: #fff; padding: 20px; border-radius: 8px; margin-bottom: 20px; max-width: 500px; margin: 0 auto 20px; box-shadow: 0 2px 6px rgba(0,0,0,0.1);}
  label { display:block; margin-top: 10px; font-weight: 600; }
  input, select, textarea { width: 100%; padding: 8px; margin-top: 4px; border-radius: 6px; border: 1px solid #ccc; }
  button { margin-top: 12px; padding: 10px 16px; border:none; border-radius:6px; background:#5a3cb3; color:white; cursor:pointer; }
  button:hover { background: #4a2e9e; }
  .delete-btn { background:#e74c3c; }
  .delete-btn:hover { background:#c0392b; }
  .achievement { background: #fff; padding: 12px 16px; border-radius: 8px; margin-bottom: 12px; display:flex; align-items:center; box-shadow:0 1px 4px rgba(0,0,0,0.1); transition: transform 0.1s; }
  .achievement:hover { transform: translateX(5px); box-shadow: 0 3px 8px rgba(0,0,0,0.15); }
  .achievement img { width: 50px; height: 50px; border-radius: 50%; margin-right: 12px; object-fit:cover; border: 2px solid #5a3cb3; }
  .achievement-details { flex:1; }
  .achievement-actions button { margin-left: 6px; background:#888; }
  .achievement-actions button.edit-btn { background:#f39c12; }
  .achievement-actions button.edit-btn:hover { background:#e67e22; }
  .achievement-actions button.delete-btn { background:#e74c3c; }
  .achievement-actions button.delete-btn:hover { background:#c0392b; }
  .checkbox-container { margin-right: 12px; }
  .search-container {
    max-width: 500px;
    margin: 0 auto 20px auto;
    background: #fff;
    padding: 15px 20px;
    border-radius: 8px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    display: flex;
    gap: 10px;
    align-items: center;
  }
  .search-container input {
    flex: 1;
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 6px;
    font-size: 1rem;
    margin: 0;
  }
  .search-container button {
    margin: 0;
    padding: 10px 20px;
    background: #5a3cb3;
    white-space: nowrap;
  }
  .stats-badge {
    display: inline-block;
    background: #5a3cb3;
    color: white;
    padding: 3px 8px;
    border-radius: 20px;
    font-size: 0.8em;
    margin-left: 8px;
  }
  .condition-badge {
    display: inline-block;
    background: #e8e4f5;
    color: #5a3cb3;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 0.85em;
    font-weight: 600;
    margin-right: 5px;
  }
  .active-badge {
    display: inline-block;
    background: #27ae60;
    color: white;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 0.85em;
  }
  .inactive-badge {
    background: #95a5a6;
  }
  .toolbar {
    max-width: 1200px;
    margin: 0 auto 20px;
    display: flex;
    gap: 10px;
    justify-content: flex-end;
  }
</style>
</head>
<body>

<h1>üèÜ Achievements Admin - Organized by Metrics</h1>

<form id="achievementForm">
  <input type="hidden" id="achId">
  <label for="title">Title</label>
  <input type="text" id="title" required>

  <label for="description">Description</label>
  <textarea id="description" rows="2"></textarea>

  <label for="conditionType">Condition Type</label>
  <select id="conditionType">
    <option value="poemsSubmitted">Poems Submitted</option>
    <option value="likesReceived">Likes Received</option>
    <option value="commentsMade">Comments Made</option>
    <option value="commentsReceived">Comments Received</option>
  </select>

  <label for="conditionMin">Minimum Value</label>
  <input type="number" id="conditionMin" min="1" required>

  <label for="active">Active</label>
  <input type="checkbox" id="active" checked>

  <label for="badgeImage">Badge Image</label>
  <input type="file" id="badgeImage" accept="image/*">

  <button type="submit">Save Achievement</button>
  <button type="button" id="cancelEdit" style="background:#95a5a6;">Cancel Edit</button>
</form>

<div class="toolbar">
  <button id="deleteSelected" class="delete-btn">üóëÔ∏è Delete Selected</button>
</div>

<!-- Universal Search -->
<div class="search-container">
  <input type="text" id="universalSearch" placeholder="Search by title, description, condition type, or min value...">
  <button id="searchButton">üîç Search</button>
  <button id="clearSearch" style="background:#95a5a6;">‚úñ Clear</button>
</div>

<!-- Categories will be dynamically populated here -->
<div id="categoriesContainer"></div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { getFirestore, collection, addDoc, getDocs, doc, updateDoc, deleteDoc, getDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyC4DHI8aBVY4JjTvJ-r-TGIDPsewtEWxzU",
  authDomain: "silent-depth.firebaseapp.com",
  projectId: "silent-depth",
  storageBucket: "silent-depth.appspot.com",
  messagingSenderId: "78008755450",
  appId: "1:78008755450:web:3fd0f0f298a08820935543"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

let selectedImageFile = null;
let currentFilter = '';

document.getElementById("badgeImage").addEventListener("change", (e) => {
  selectedImageFile = e.target.files[0] || null;
});

// Cancel edit
document.getElementById("cancelEdit").addEventListener("click", () => {
  document.getElementById("achievementForm").reset();
  document.getElementById("achId").value = "";
  selectedImageFile = null;
});

// Upload image
async function uploadToCloudinary(file) {
  if (!file) return "";
  const cloudName = "dzoq4pgjn";
  const uploadPreset = "achievements";
  const formData = new FormData();
  formData.append("file", file);
  formData.append("upload_preset", uploadPreset);

  try {
    const res = await fetch(`https://api.cloudinary.com/v1_1/${cloudName}/image/upload`, {
      method: "POST",
      body: formData
    });
    const data = await res.json();
    return data.secure_url;
  } catch (err) {
    console.error("Cloudinary upload failed:", err);
    alert("Image upload failed.");
    return "";
  }
}

// Form submission
const form = document.getElementById("achievementForm");
form.addEventListener("submit", async (e) => {
  e.preventDefault();
  const title = document.getElementById("title").value.trim();
  const description = document.getElementById("description").value.trim();
  const type = document.getElementById("conditionType").value;
  const min = parseInt(document.getElementById("conditionMin").value);
  const active = document.getElementById("active").checked;
  const achId = document.getElementById("achId").value;

  let imageUrl = "";
  if (selectedImageFile) imageUrl = await uploadToCloudinary(selectedImageFile);

  try {
    if (achId) {
      const achRef = doc(db, "achievements", achId);
      const updateData = { title, description, condition: { type, min }, active };
      if (imageUrl) updateData.imageUrl = imageUrl;
      await updateDoc(achRef, updateData);
    } else {
      await addDoc(collection(db, "achievements"), {
        title, description, condition: { type, min }, imageUrl, active
      });
    }
    form.reset();
    document.getElementById("achId").value = "";
    selectedImageFile = null;
    loadAchievements();
  } catch (err) {
    console.error(err);
    alert("Failed to save achievement.");
  }
});

let allAchievements = [];

// Load and organize achievements
async function loadAchievements() {
  const snapshot = await getDocs(collection(db, "achievements"));
  allAchievements = snapshot.docs.map(docSnap => ({ id: docSnap.id, ...docSnap.data() }));
  
  // Apply search filter if active
  const filtered = currentFilter ? filterAchievements(allAchievements, currentFilter) : allAchievements;
  
  // Organize by condition type and sort by min value
  displayOrganizedAchievements(filtered);
}

// Filter achievements based on search term
function filterAchievements(achievements, searchTerm) {
  const term = searchTerm.toLowerCase();
  return achievements.filter(ach => {
    return (ach.title && ach.title.toLowerCase().includes(term)) ||
           (ach.description && ach.description.toLowerCase().includes(term)) ||
           (ach.condition && ach.condition.type && ach.condition.type.toLowerCase().includes(term)) ||
           (ach.condition && ach.condition.min && ach.condition.min.toString().includes(term));
  });
}

// Display achievements organized by category, sorted by min value
function displayOrganizedAchievements(achievements) {
  const container = document.getElementById("categoriesContainer");
  container.innerHTML = "";
  
  if (achievements.length === 0) {
    container.innerHTML = '<div style="text-align:center; padding:40px; background:#fff; border-radius:8px;">üîç No achievements match your search.</div>';
    return;
  }

  // Group by condition type
  const categories = {
    poemsSubmitted: { name: 'üìù Poems Submitted', icon: 'üìù', achievements: [] },
    likesReceived: { name: '‚ù§Ô∏è Likes Received', icon: '‚ù§Ô∏è', achievements: [] },
    commentsMade: { name: 'üí¨ Comments Made', icon: 'üí¨', achievements: [] },
    commentsReceived: { name: 'üì® Comments Received', icon: 'üì®', achievements: [] }
  };

  // Categorize achievements
  achievements.forEach(ach => {
    const type = ach.condition?.type;
    if (type && categories[type]) {
      categories[type].achievements.push(ach);
    }
  });

  // Sort achievements within each category by min value (ascending)
  Object.values(categories).forEach(category => {
    category.achievements.sort((a, b) => (a.condition?.min || 0) - (b.condition?.min || 0));
  });

  // Calculate stats
  const totalAchievements = achievements.length;
  const activeCount = achievements.filter(a => a.active).length;

  // Display summary
  const summaryDiv = document.createElement('div');
  summaryDiv.className = 'category-summary';
  summaryDiv.innerHTML = `
    üìä Total: ${totalAchievements} achievements | ‚úÖ Active: ${activeCount} | üîç ${currentFilter ? 'Filtered' : 'All'}
  `;
  container.appendChild(summaryDiv);

  // Display each category
  Object.values(categories).forEach(category => {
    if (category.achievements.length === 0) return;

    const categoryDiv = document.createElement('div');
    categoryDiv.innerHTML = `
      <h2>
        ${category.icon} ${category.name} 
        <span class="stats-badge">${category.achievements.length}</span>
      </h2>
    `;

    const achievementsList = document.createElement('div');
    achievementsList.className = 'category-achievements';

    // Add achievements in order (lowest to highest)
    category.achievements.forEach(data => {
      const div = document.createElement("div");
      div.className = "achievement";
      
      // Add visual indicator for achievement level
      const level = getAchievementLevel(data.condition?.min || 0, category.achievements);
      
      div.innerHTML = `
        <input type="checkbox" class="select-achievement checkbox-container" data-id="${data.id}">
        <img src="${data.imageUrl || 'https://via.placeholder.com/50/5a3cb3/ffffff?text=üèÜ'}" alt="badge">
        <div class="achievement-details">
          <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
            <strong>${data.title}</strong>
            <span class="condition-badge">${level}</span>
            <span class="active-badge ${data.active ? '' : 'inactive-badge'}">${data.active ? '‚úÖ Active' : '‚≠ï Inactive'}</span>
          </div>
          <div style="color:#666; margin:4px 0;">${data.description}</div>
          <div style="font-size:0.9em;">
            <span style="background:#f0f0f0; padding:2px 6px; border-radius:4px;">
              ${data.condition.type} ‚â• ${data.condition.min}
            </span>
          </div>
        </div>
        <div class="achievement-actions">
          <button class="edit-btn" onclick="editAchievement('${data.id}')">‚úèÔ∏è Edit</button>
          <button class="delete-btn" onclick="deleteAchievement('${data.id}')">üóëÔ∏è Delete</button>
        </div>
      `;
      achievementsList.appendChild(div);
    });

    categoryDiv.appendChild(achievementsList);
    container.appendChild(categoryDiv);
  });
}

// Helper function to determine achievement level within its category
function getAchievementLevel(minValue, categoryAchievements) {
  const values = categoryAchievements.map(a => a.condition?.min || 0).sort((a, b) => a - b);
  const index = values.indexOf(minValue);
  
  if (index === 0) return 'ü•â Beginner';
  if (index === 1) return 'ü•à Intermediate';
  if (index === 2) return 'ü•á Advanced';
  if (index > 2) return `‚≠ê Level ${index + 1}`;
  return 'üéØ Achievement';
}

// Search functionality
function performSearch() {
  const searchTerm = document.getElementById("universalSearch").value.trim().toLowerCase();
  currentFilter = searchTerm;
  
  if (searchTerm === '') {
    currentFilter = '';
    displayOrganizedAchievements(allAchievements);
  } else {
    const filtered = filterAchievements(allAchievements, searchTerm);
    displayOrganizedAchievements(filtered);
  }
}

// Clear search
document.getElementById("clearSearch").addEventListener("click", () => {
  document.getElementById("universalSearch").value = '';
  currentFilter = '';
  displayOrganizedAchievements(allAchievements);
});

// Edit achievement
window.editAchievement = async (id) => {
  const achRef = doc(db, "achievements", id);
  const docSnap = await getDoc(achRef);
  if (!docSnap.exists()) return;
  const data = docSnap.data();
  document.getElementById("title").value = data.title || "";
  document.getElementById("description").value = data.description || "";
  document.getElementById("conditionType").value = data.condition.type || "poemsSubmitted";
  document.getElementById("conditionMin").value = data.condition.min || 1;
  document.getElementById("active").checked = data.active || false;
  document.getElementById("achId").value = id;
  selectedImageFile = null;
  window.scrollTo({ top: 0, behavior: 'smooth' });
}

// Delete single achievement
window.deleteAchievement = async (id) => {
  if (!confirm("Are you sure you want to delete this achievement?")) return;
  await deleteDoc(doc(db, "achievements", id));
  await loadAchievements();
}

// Delete selected achievements
document.getElementById("deleteSelected").addEventListener("click", async () => {
  const checkboxes = document.querySelectorAll(".select-achievement:checked");
  if (checkboxes.length === 0) return alert("Select at least one achievement to delete.");
  if (!confirm(`Are you sure you want to delete ${checkboxes.length} selected achievement(s)?`)) return;

  for (const cb of checkboxes) {
    const id = cb.dataset.id;
    await deleteDoc(doc(db, "achievements", id));
  }
  await loadAchievements();
});

// Attach search event listeners
document.getElementById("searchButton").addEventListener("click", performSearch);
document.getElementById("universalSearch").addEventListener("keyup", (e) => {
  if (e.key === 'Enter') {
    performSearch();
  }
});

// Initial load
loadAchievements();
</script>

</body>
</html>